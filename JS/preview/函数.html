<html>
  <head>
	  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>i5ting_ztree_toc:函数</title>
		<link href="toc/style/github-bf51422f4bb36427d391e4b75a1daa083c2d840e.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/style/github2-d731afd4f624c99a4b19ad69f3083cd6d02b81d5.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/zTreeStyle/zTreeStyle.css" media="all" rel="stylesheet" type="text/css"/>
		<!-- <link href="toc/css/highlight/agate.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/androidstudio.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/arduino-light.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/arta.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/ascetic.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/atelier-cave-dark.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/atelier-cave-light.css" media="all" rel="stylesheet" type="text/css"/> -->
		<!-- <link href="toc/css/highlight/atelier-dune-dark.css" media="all" rel="stylesheet" type="text/css"/> -->
		<!-- <link href="toc/css/highlight/atelier-dune-light.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/atelier-estuary-dark.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/atelier-estuary-light.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/atelier-forest-dark.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/atelier-forest-light.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/atelier-heath-dark.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/atelier-heath-light.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/atelier-lakeside-dark.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/atelier-lakeside-light.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/atelier-plateau-dark.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/atelier-plateau-light.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/atelier-savanna-dark.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/atelier-savanna-light.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/atelier-seaside-dark.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/atelier-seaside-light.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/atelier-sulphurpool-dark.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/atelier-sulphurpool-light.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/atom-one-dark.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/atom-one-light.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/brown-paper.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/codepen-embed.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/color-brewer.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/darcula.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/dark.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/darkula.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/default.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/docco.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/dracula.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/far.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/foundation.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/github-gist.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/github.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/googlecode.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/grayscale.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/gruvbox-dark.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/gruvbox-light.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/hopscotch.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/hybrid.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/idea.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/ir-black.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/kimbie.dark.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/kimbie.light.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/magula.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/mono-blue.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/monokai-sublime.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/monokai.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/obsidian.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/ocean.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/paraiso-dark.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/paraiso-light.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/pojoaque.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/purebasic.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/qtcreator_dark.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/qtcreator_light.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/railscasts.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/rainbow.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/routeros.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/school-book.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/solarized-dark.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/solarized-light.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/sunburst.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/tomorrow-night-blue.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/tomorrow-night-bright.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/tomorrow-night-eighties.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/tomorrow-night.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/tomorrow.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/vs.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/vs2015.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/xcode.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/xt256.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/zenburn.css" media="all" rel="stylesheet" type="text/css"/> -->

		<link href="toc/css/highlight/school-book.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="../assets/bootstrap/css/bootstrap.css" rel="stylesheet">
	  <style>
		pre {
		    counter-reset: line-numbering;
		    border: solid 1px #d9d9d9;
		    border-radius: 0;
		    background: #fff;
		    padding: 0;
		    line-height: 23px;
		    margin-bottom: 30px;
		    white-space: pre;
		    overflow-x: auto;
		    word-break: inherit;
		    word-wrap: inherit;
		}

		pre a::before {
		  content: counter(line-numbering);
		  counter-increment: line-numbering;
		  padding-right: 1em; /* space after numbers */
		  width: 25px;
		  text-align: right;
		  opacity: 0.7;
		  display: inline-block;
		  color: #aaa;
		  background: #eee;
		  margin-right: 16px;
		  padding: 2px 10px;
		  font-size: 13px;
		  -webkit-touch-callout: none;
		  -webkit-user-select: none;
		  -khtml-user-select: none;
		  -moz-user-select: none;
		  -ms-user-select: none;
		  user-select: none;
		}

		pre a:first-of-type::before {
		  padding-top: 10px;
		}

		pre a:last-of-type::before {
		  padding-bottom: 10px;
		}

		pre a:only-of-type::before {
		  padding: 10px;
		}

		.highlight { background-color: #ffffcc } /* RIGHT */
		</style>
  </head>
  <body>
	  <div>
				<div style='width:25%;'>
						<ul id="tree" class="ztree" style='width:100%'>

						</ul>
				</div>
        <div id='readme' style='width:70%;margin-left:20%;'>
          	<article class='markdown-body'>
            	<p>#
<a href="../index.html"></a></p>
<h1 id="-">函数</h1>
<h2 id="-">函数的定义和使用</h2>
<pre><code class="lang-JavaScript">    什么是函数：可以重复执行的代码块！

    循环语句也可以重复执行，为什么还要使用函数？？？
        1.逻辑调用不能省略；函数调用更加简便（  函数名()  ）
        2.循环语句大部分时候在循环执行;函数可以更灵活的修改其中的一部分值;

    函数：哪里需要哪里调用，灵活;

    函数的定义方法：2种;

    第一种：字面量;
    函数不调用不执行;     调用：函数名();
    fn();//调用可以在定义之前
    function fn(){
        alert(&quot;hello world!!!&quot;);
    }

    第二种：变量赋值;
    var fun = function(){
        alert(222);
    }

    //只能在下面调用；
    fun();
</code></pre>
<h2 id="-">函数的参数</h2>
<pre><code class="lang-JavaScript">    参数：1.形参；   2.实参;
    1.形参：形式上参与运算的变量;
    2.实参：实际上参与运算的值;
    为了增加函数的功能性，和程序员的交互性，和可拓展性;给他增加变量；
        fn(333,222);//333和222就是实参；
        function fn(a,b){//a和b就是形参;
            alert(a+b);
        }
    总结：形参是给实参占位置;
    形参和实参个数不符合;
        1.实参多;写多了，参数传多了！ 传多了，我们不用！！！
        2.实参正好;无意义，正常执行;
        3.实参少;没有传的用undefined补充！

    1.实参多;写多了，参数传多了！ 传多了，我们不用！！！
         fn(1,2,3,4,5,6);//传多了，我们不用！！！
    2.实参正好;无意义，正常执行;
         fn(1,2);
    3.实参少;没有传的用undefined补充！
        fn(1);
        function fn(a,b){
            alert(a+b)
            console.log(a);
            console.log(b);
        }
    js中没有方法重载：两个参数和三个参数和...，都一样，后面的方法把前面的方法覆盖掉;
        fn(){

        }
        fn(a,b){

        }
</code></pre>
<h2 id="-">函数参数案例</h2>
<pre><code class="lang-JavaScript">    1.求1-n之间所有数的和
    2.求n-m之间所有数的和
    3.圆的面积
    4.求2个数中的最大值
    5.求3个数中的最大值

    求1-n之间所有数的和

    getSum(10);
    function getSum(n){
        var sum = 0;
        for(var i=1;i&lt;=n;i++){
            sum += i;
        }
        alert(sum);
    }

    求n-m之间所有数的和
    getSum(9,10);
    function getSum(n,m){
        var sum = 0;
        for(var i=n;i&lt;=m;i++){
            sum+=i;
        }
        alert(sum);
    }

    圆的面积
        公式： area = 3.14*r*r;
    getArea(10);
    function getArea(r){
        var area = 3.14*r*r;
        alert(area);
    }

    求2个数中的最大值
    getMaxOfTwo(3,2);
    function getMaxOfTwo(num1,num2){
    //     if(num1&gt;num2){
    //         alert(num1);
    //     }else{
    //         alert(num2);
    //     }
        //三元运算符
        var max = num1&gt;num2?num1:num2;
        alert(max);
    }

    求3个数中的最大值
    getMaxOfThree(4,6,3);
    function getMaxOfThree(a,b,c){
    两两比较，前两个比较完毕在比较后两个;
    if(a&gt;b){
    //a大，然后在和c比较;
    if(a&gt;c){
        //a&gt;b&amp;&amp;a&gt;c;
        alert(a);
    }else{
        //c&gt;a&gt;b
        alert(c);
    }
    }else{
    //b&gt;a的；和c比较
    if(b&gt;c){
        //b&gt;a&amp;&amp;b&gt;c;
        alert(b);
    }else{
        //c&gt;b&gt;a;
        alert(c);
    }
    }

    优化1: 三元运算符;
    var max = a&gt;b?a:b;
    max = max&gt;c?max:c;
    alert(max);

    优化2: 三元运算符;
    var max = a&gt;b?a:b;
    max = max&gt;c?max:c;

    var max = a&gt;b?a:b&gt;c?a&gt;b?a:b:c
    var max = (a&gt;b?a:b)&gt;c?(a&gt;b?a:b):c;
    alert(a&gt;b?a:b&gt;c?a&gt;b?a:b:c);
    }
</code></pre>
<h2 id="-">函数的返回值</h2>
<pre><code class="lang-JavaScript">       函数的返回值：函数内部的变量或者值外部无法使用所以需要返回;
        函数通过运算出来的结果，如果外部需要使用请通过return进行返回，外部才能够使用;

        var num = fn();
        //    alert(aaa);
        alert(num);

        function fn(){
            var aaa = 111;
            //如果想要让外部使用的话，通过关键字return进行返回，外部才能接收;
            return aaa;
        }

        函数返回值注意点：
        如果函数没有显示的使用 return语句 ，那么函数有默认的返回值：undefined
        如果函数使用 return语句，那么跟再return后面的值，就成了函数的返回值
        如果函数使用 return语句，但是return后面没有任何值，那么函数的返回值也是：undefined
        函数使用return语句后，这个函数会在执行完 return 语句之后停止并立即退出，也就是说return后面的所有其他代码都不会再执行。

        fn();
        function fn(){
            return;//return有切断函数的功能;下面不在执行;
            console.log(1);
            console.log(2);
            console.log(3);
        }
</code></pre>
<h2 id="-">函数返回值案例</h2>
<pre><code class="lang-JavaScript">        1.求一组数中的最大值
        2.求一组数中的最小值
        3.求阶乘
        4.求1!+2!+3!+....+n!

        1.求一组数中的最大值
            var arr = [1,2,3,4,5];

            //测试
            var aaa = getMax(arr);
            alert(aaa);
            //封装一个函数，获取最大值;
            //参数: 数组    返回值：最大值;
            function getMax(array){
                //吧数组中的第一个设置为最大值
                var max = array[0];
                //通过for循环比较
                for(var i=1;i&amp;lt;array.length;i++){
                    if(max &lt; array[i]){
                        max = array[i];
                    }
                }
                //返回最大值
                return max;
            }

        3.求阶乘
            5! = 5*4*3*2*1;
            4! = 4*3*2*1;
            ....

             alert(getJC(4));

              function getJC(num){
                  var product = 1;
                  for(var i=1;i&lt;=num;i++){
                      product*=i;
                  }
                  //返回
                  return product;
              }

        2.求一组数中的最小值
              var arr = [-1,-2,-3,-4,-5];

            //测试
                 var aaa = getMin(arr);
                 alert(aaa);
            //拓展
            alert(getMin(arr));//打印的就是函数的返回值；
                    //执行函数getMin();并把返回值扔在这里
            //封装
            function getMin(a){
                var min = a[0];
                //for循环判断
                for(var i=1;i&lt; a.length;i++){
                    if(min &gt; a[i]){
                        min = a[i];
                    }
                }
                //返回值
                return min;
            }

           4.求1!+2!+3!+....+n!
            求阶乘的和;(同级函数可以嵌套使用)
                function getJCSum(n){
                    //求和;
                    var sum = 0;
                    //for循环
                    for(var i=1;i&lt;=n;i++){
                        //阶乘的和;
                        sum += getJC(i);//i取值，第一轮是1，第二轮是2，第三轮是3....
                    }
                    return sum;
                }

            //测试
            alert(getJCSum(5));
</code></pre>
<h2 id="-">函数的返回值问题</h2>
<pre><code class="lang-JavaScript">           1.函数如果没有return和有return没有值返回的都是  undefined;
        2.return可以切断函数；
        3.一个函数中不一定只有一个return,但是只能执行一个return;

            function getMax(n1,n2){
                if(n1&gt;n2){
                    return n1;
                }
                return n2;
            }
</code></pre>
<h2 id="-">函数的案例</h2>
<pre><code class="lang-JavaScript">    1.求斐波那契数列Fibonacci中的第n个数是多少？      1 1 2 3 5 8 13 21...
        2.翻转数组，返回一个新数组
        3.对数组排序，从小到大
        4.判断一个数是否是素数(又叫质数，只能被1和自身整数的数)
        5.输入一个年份，判断是否是闰年[闰年：能被4整数并且不能被100整数，或者能被400整数]

        1.求斐波那契数列Fibonacci中的第n个数是多少？
          1 1 2 3 5 8 13 21...

        alert(FBNQSL(12))的
        //封装一个数列，返回第几个数值;
        function FBNQSL(n){
        //        if(n&lt;1){
        //            return &quot;无意义！&quot;;//不让下面代码执行
        //        }
            //定义两个变量
            var n1 = 1;
            var n2 = 1;
            //for循环从第3个开始，轮回
            for(var i=3;i&lt;=n;i++){
                //第三项开始当前项等于前两项之和;先存储好后一项
                var temp = n2;
                n2 = n1+n2;
                n1 = temp;
            }

            //return  后一个变量
            return n2;
        }

        2.翻转数组，返回一个新数组
        var arr = [1,2,3];
        console.log(arr);

        //测试
        console.log(rev1(arr));

        function rev1(array){
            var newArr = [];
            //反向遍历正向添加;
            for(var i=array.length-1;i&gt;=0;i--){
                newArr[newArr.length] = array[i];
            }
            //把新创建的数组返回
            return newArr;
        }

        3.对数组排序，从小到大
            冒泡排序
        var arr = [3,2,4,6,1,5];
        console.log(bubble(arr));
        function bubble(a){
            //外循环控制轮数，内循环控制次数，都是元素个数-1；
            for(var i = 0;i&lt; a.length-1;i++){
                //轮数优化;变量定义到两个for循环之间
                var bool = true;
                for(var j=0;j&lt; a.length-1-i;j++){
                    //满足条件交换位置
                    if(a[j] &gt; a[j+1]){
                        var temp = a[j];
                        a[j] = a[j+1];
                        a[j+1] = temp;
                        //任何两个元素交换位置，都不能跳出循环了
                        bool = false;
                    }
                }
                //判断：如果没有交换位置就跳出循环
                if(bool){
                    break;
                }
            }
            //把数组返回
            return a;
        }

        4.判断一个数是否是素数(又叫质数，只能被1和自身整数的数)
                正向不好判断：如果可以分成x*y就不是素数;
        alert(isPrime(2));
        alert(isPrime(3));
        alert(isPrime(4));
        alert(isPrime(5));
        function isPrime(num){
            //思路：判断2到num-1之间所有的数，是否有能够被整除的
            for(var i=2;i&lt;=num-1;i++){
                //判断：整个for循环中的i，如果有一个能够被整除也不是素数;
                if(num%i == 0){
                    //整除了，就不是素数;
                    return false;
                }
            }
            //如果整轮循环都不能证明他不是一个素数，那他就一定是一个素数;
            return true;
        }

        //拓展：
        function isPrime(num){
            //开闭原则;
            var bool = true;
            //没有必要判断到num，因为超过一半后面的就没有意义了，商只能是1.000001-1.9999之间;
            for(var i=2;i&lt;=num/2;i++){
                if(num%i == 0){
                    bool = false;
                    break;//有一个能够整除后面的就不用看了！
                }
            }
            return bool;
        }

        5.输入一个年份，判断是否是闰年[闰年：能被4整数并且不能被100整数，或者能被400整数]
        function isRN(year){
            //能被4整数并且不能被100整数，或者能被400整数
            if(year%4==0 &amp;&amp; year%100!=0 || year%400 ==0){
                return true;
            }
            return false;
        }

    拓展
        function isRN(year){
            //能被4整数并且不能被100整数，或者能被400整数
            var bool = false;//这个开闭原则默认为不通过！
            if(year%4==0 &amp;&amp; year%100!=0 || year%400 ==0){
                bool = true;
            }
            return bool;
        }

    1.输入某年某月某日，判断这一天是这一年的第几天？
        思路：累加当月的天数，之前月份的所有天数，和当前是否是闰年;
        自定义一个数组，装着每个月的天数，以平年为准
         ，如果是闰年，且大于2月，增加1天;

    测试：
        alert(getDay(2015,1,1));
        alert(getDay(2015,2,1));

        alert(getDay(2015,3,1));//平年
        alert(getDay(2016,3,1));//闰年

        function getDay(year,month,day){
            //累计天数;  日期，月份，闰年;
            var arr = [31,28,31,30,31,30,31,31,30,31,30,31];
            //日期
            var sum = day;
            //月份:1.月份索引值为0；   2.不能获取当前月份;
            for(var i=0;i&amp;lt;month-1;i++){//month-1不希望取到当前月份;
                sum+=arr[i];//索引值从0开始，不能写等号，不能取到当前月份;
            }
            //闰年,且大于2月;
            if(isRN(year) &amp;&amp; month&gt;2){//函数嵌套
                sum++;
            }
            //把总天数返回
            return sum;
        }


    //    判断：是不是闰年
        function isRN(y){
            if(y%4==0&amp;&amp;y%100!=0||y%400==0){
                return true;
            }
            return false;
        }
</code></pre>
<h2 id="arguments-">arguments对象</h2>
<pre><code class="lang-JavaScript">       只有在函数中才存在arguments;  实参组成的一个数组;
            1.callee: 整个函数;
            2.length: 实参个数;

        console.log(arguments);

        fn(1,2,3,4,5,6,7);
        function fn(a,b){
            console.log(arguments);//实参数组
            console.log(arguments.length);//实参数个
            console.log(fn.length);//形参数个

            console.log(arguments.callee);//整个函数
            document.write(arguments.callee);//整个函数
        }
</code></pre>
<h2 id="-">匿名函数和自调用</h2>
<pre><code class="lang-JavaScript">        匿名函数：没有名字的函数;
            function (){
                alert(111);
            }

        用处;(百万雄师下江南...)
        //1.事件绑定;
             document.onclick = function(){alert(111);}
        //2.定时器;
             setInterval(function(){console.log(222)},1000);
        //3.事件监听....


        函数的自调用;
            fn();//函数名();
            function fn(){
                alert(333);
            }
        //函数名 === 整个函数;
        document.write(fn);


        匿名函数可以自己调用自己
            (function (){
                alert(&quot;我是匿名函数&quot;);
            })();
</code></pre>
<h2 id="-">函数小技巧</h2>
<pre><code class="lang-JavaScript">    0.函数不调用不执行;
    1.函数名就等于（整个函数）
    2.就近原则使用变量
    3.两个平级的函数中的变量不会相互影响（可以使用同样的形参名）

    0.函数不调用不执行;
    1.函数名就等于（整个函数）
        function fn(){
            console.log(111);
        }
        document.write(fn);

        打印函数名和打印执行函数的区别:
        document.write(fn);//整个函数；
        document.write(fn());//功能+打印返回值

    2.就近原则使用变量
        var num = 111;
        var aaa = 111;
        fn(222)
        function fn(aaa){
            //函数自己有，不会使用别人的;
            var num = 222;
            console.log(num);
            console.log(aaa);//也是使用自己的;
        }

    3.两个平级的函数中的变量不会相互影响（可以使用同样的形参名）
        function fn1(aaa){
            console.log(aaa);
        }
        function fn2(aaa){
            console.log(aaa);
        }

        fn1(111);
        fn2(222);
</code></pre>
<h2 id="-">递归-闭包-回调函数</h2>
<pre><code class="lang-JavaScript">    递归：函数自己调用自己;
    递归必须有跳出条件，否则就是死循环;
        var num = 1;
        fn();
        function fn(){
            console.log(num);
            num++;
            if(num == 11){
                return;//跳出条件；
            }
            fn();
        }

    闭包：函数作为返回值;
            函数内部的变量让外部使用;
        function fn(){
            return function () {
                console.log(111);
            }
        }

    回调函数：函数作为参数进行传递和调用;被传递和调用的函数就叫回调函数；

    案例1：
        fn(test1);

        function fn(aaa){
            aaa();//aaa他一定是一个函数;回调函数；
        }

        function test1(){
            console.log(&quot;我是作为回调函数的函数，用于测试！！！&quot;);
        }

    案例2：
        fn(1,2,test1);

        function fn(num1,num2,demo){
            demo(num1,num2);//demo是回调函数;把fn的两个参数，作为自己的实参传递进去了
        }

        function test1(n1,n2){
            alert(n1+n2);
        }

    案例3：回调函数一般用于定义一种规则;

        测试回调函数;
        fn(10,5,test1);
        fn(10,5,test2);
        fn(10,5,test3);
        fn(10,5,test4);

        //定义加减乘除四则运算规则;
        function fn(num1,num2,demo){
            var num = demo(num1,num2);
            alert(num);
        }

        //定义加减乘除四则运算规则;
        function test1(n1,n2){
            var aaa = n1 + n2;
            return aaa;
        }
        function test2(n1,n2){
            return n1 - n2;
        }
        function test3(n1,n2){
            return n1 * n2;
        }
        function test4(n1,n2){
            return n1 / n2;
        }
</code></pre>
<h2 id="-">函数总结</h2>
<pre><code class="lang-JavaScript">        函数三点需要我们注意：

        1.封装;功能和逻辑是最难的;
                需要经验的积累!!!(需要经验)

        2.参数;什么时候定义参数，定义谁为参数！
                谁变化就定义谁为参数!!!(需要经验)

        3.返回值; 函数内部计算的变量外部想要使用就用return返回;
                外部使用内部值的时候;(如果使用的是逻辑和功能，就不用了)(需要经验)

        函数使用一般用两点：a.返回值;  b.逻辑和功能;
</code></pre>
<h2 id="-">变量和作用域</h2>
<pre><code class="lang-JavaScript">    根据作用范围的不同变量可以分为两类：
    1.全局变量(成员变量);哪里都可以访问到的变量;
            a.函数外部的用var定义的变量就是全局变量；
            b.任何位置不适用var定义的变量都是全局变量；
                    函数范围内的不适用var定义的全局变量需要执行一次函数才能访问;
    2.局部变量;只有在局部范围内能够访问的变量;
            a.函数范围内，使用var定义的变量;

        var num1 = &quot;我是全局变量1&quot;;
        num2 = &quot;我是全局变量2&quot;;
        console.log(num1);
        console.log(num2);

    //在函数里面也可以访问到全局变量
    fn();
        console.log(num2);//外部无法使用函数内部的局部变量
        console.log(num3);//函数加载的时候只加载函数名，不加载函数体;

        function fn(){
            var num22 = &quot;我是局部变量&quot;;
            num3 = &quot;我是全局变量3&quot;;
            console.log(num1);
            console.log(num22);
            console.log(num2);
            console.log(num3);
        }

    全局变量：哪里都能够访问到，污染变量；
    局部变量：只有函数内部能够够访问到，函数执行完毕立刻回收；

    隐式全局变量：就是不容易被发现的全局变量;
        fn();
        console.log(a);
        console.log(b);
        console.log(c);

        function fn(){
            =并不能公用一个var；
            var a = b = c = 1;//a局部变量，b和c就是隐式全局变量;
            ;并不能公用一个var；
            var a = 1;b=2;c=3;//a局部变量，b和c是隐式全局变量;
            ,可以公用一个var；
            var a = 1,b= 2,c=3;//a局部变量，b和c局部变量，
        }

    作用域链; 只能在同一函数中调用里面的函数，不能跨越函数;
                除非顶级函数，可以两个相互嵌套调用;
        f1();
        function f1(){
            f3();
            f4();//无法访问;

            function f2(){

            }
        }

        function f3(){
            function f4(){
                //无法访问：f1和f2;
            }
        }
</code></pre>
<h2 id="-">预解析</h2>
<pre><code class="lang-JavaScript">        预解析：js代码和函数加载的时候，先不执行，js看一眼;
            1.解决语法错误;
            2.变量和函数声明提升;

        1.解决语法错误;
        console.log(111);
        console.log(222);
        console.log(aaa;

        2.变量和函数声明提升;(在函数中照样会出现)
                a.变量声明提升的时候，只提升变量名，不提升变量值;(必须带有var)
                b.函数声明提升的时候，提升变量名和值（整体提升）;
                c.声明提升的时候先提升变量，在提升函数;(函数的权限比变量的权限高)

        a.变量声明提升的时候，只提升变量名，不提升变量值;
            var num;
            console.log(num);
            num = 111;

        b.函数声明提升的时候，提升变量名和值（整体提升）;
            console.log(fn);
            function fn(){
                console.log(222);
            }

        c.声明提升的时候先提升变量，在提升函数;
               var aaa;
               function aaa(){//把变量层叠掉；

               }

            console.log(aaa);
            aaa = 111;//把函数层叠掉；
            function aaa(){//把变量层叠掉；

            }
            console.log(aaa);
</code></pre>
<h2 id="-">面试题</h2>
<pre><code class="lang-JavaScript">    案例1
        var a = 25;
        function abc() {
        //  var a;
            alert(a);
            var a = 10;//就近原则;
        }
        abc();

         案例2:变量声明提升在函数声明提升之前；
        var a;
        function a() {
            console.log(&#39;aaaaa&#39;);
        }

        console.log(a);
        function a() {
            console.log(&#39;aaaaa&#39;);
        }
        var a = 1;
        console.log(a);
</code></pre>

          	</article>
        </div>
		</div>
  </body>
</html>
<script type="text/javascript" src="toc/js/jquery-1.4.4.min.js"></script>
<script type="text/javascript" src="toc/js/jquery.ztree.all-3.5.min.js"></script>
<script type="text/javascript" src="toc/js/ztree_toc.js"></script>
<script type="text/javascript" src="toc_conf.js"></script>
<script type="text/javascript" src="toc/js/highlight.pack.js"></script>

<SCRIPT type="text/javascript" >
<!--
$(document).ready(function(){
	$('pre code').each(function(i, block) {
    		hljs.highlightBlock(block);
  		});
    var css_conf = eval(markdown_panel_style);
    $('#readme').css(css_conf)
    
    var conf = eval(jquery_ztree_toc_opts);
		$('#tree').ztree_toc(conf);

		
  		$('#readme a:eq(0)').addClass('list-group-item active');
});
//-->
//

</SCRIPT>