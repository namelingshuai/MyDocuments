<html>
  <head>
	  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>i5ting_ztree_toc:对象</title>
		<link href="toc/style/github-bf51422f4bb36427d391e4b75a1daa083c2d840e.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/style/github2-d731afd4f624c99a4b19ad69f3083cd6d02b81d5.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/zTreeStyle/zTreeStyle.css" media="all" rel="stylesheet" type="text/css"/>
		<!-- <link href="toc/css/highlight/agate.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/androidstudio.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/arduino-light.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/arta.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/ascetic.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/atelier-cave-dark.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/atelier-cave-light.css" media="all" rel="stylesheet" type="text/css"/> -->
		<!-- <link href="toc/css/highlight/atelier-dune-dark.css" media="all" rel="stylesheet" type="text/css"/> -->
		<!-- <link href="toc/css/highlight/atelier-dune-light.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/atelier-estuary-dark.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/atelier-estuary-light.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/atelier-forest-dark.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/atelier-forest-light.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/atelier-heath-dark.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/atelier-heath-light.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/atelier-lakeside-dark.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/atelier-lakeside-light.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/atelier-plateau-dark.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/atelier-plateau-light.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/atelier-savanna-dark.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/atelier-savanna-light.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/atelier-seaside-dark.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/atelier-seaside-light.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/atelier-sulphurpool-dark.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/atelier-sulphurpool-light.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/atom-one-dark.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/atom-one-light.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/brown-paper.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/codepen-embed.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/color-brewer.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/darcula.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/dark.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/darkula.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/default.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/docco.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/dracula.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/far.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/foundation.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/github-gist.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/github.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/googlecode.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/grayscale.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/gruvbox-dark.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/gruvbox-light.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/hopscotch.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/hybrid.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/idea.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/ir-black.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/kimbie.dark.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/kimbie.light.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/magula.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/mono-blue.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/monokai-sublime.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/monokai.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/obsidian.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/ocean.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/paraiso-dark.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/paraiso-light.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/pojoaque.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/purebasic.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/qtcreator_dark.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/qtcreator_light.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/railscasts.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/rainbow.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/routeros.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/school-book.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/solarized-dark.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/solarized-light.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/sunburst.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/tomorrow-night-blue.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/tomorrow-night-bright.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/tomorrow-night-eighties.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/tomorrow-night.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/tomorrow.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/vs.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/vs2015.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/xcode.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/xt256.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/highlight/zenburn.css" media="all" rel="stylesheet" type="text/css"/> -->

		<link href="toc/css/highlight/school-book.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="../assets/bootstrap/css/bootstrap.css" rel="stylesheet">
	  <style>
		pre {
		    counter-reset: line-numbering;
		    border: solid 1px #d9d9d9;
		    border-radius: 0;
		    background: #fff;
		    padding: 0;
		    line-height: 23px;
		    margin-bottom: 30px;
		    white-space: pre;
		    overflow-x: auto;
		    word-break: inherit;
		    word-wrap: inherit;
		}

		pre a::before {
		  content: counter(line-numbering);
		  counter-increment: line-numbering;
		  padding-right: 1em; /* space after numbers */
		  width: 25px;
		  text-align: right;
		  opacity: 0.7;
		  display: inline-block;
		  color: #aaa;
		  background: #eee;
		  margin-right: 16px;
		  padding: 2px 10px;
		  font-size: 13px;
		  -webkit-touch-callout: none;
		  -webkit-user-select: none;
		  -khtml-user-select: none;
		  -moz-user-select: none;
		  -ms-user-select: none;
		  user-select: none;
		}

		pre a:first-of-type::before {
		  padding-top: 10px;
		}

		pre a:last-of-type::before {
		  padding-bottom: 10px;
		}

		pre a:only-of-type::before {
		  padding: 10px;
		}

		.highlight { background-color: #ffffcc } /* RIGHT */
		</style>
  </head>
  <body>
	  <div>
				<div style='width:25%;'>
						<ul id="tree" class="ztree" style='width:100%'>

						</ul>
				</div>
        <div id='readme' style='width:70%;margin-left:20%;'>
          	<article class='markdown-body'>
            	<p><a href="../index.html">首页</a></p>
<h1 id="-">对象</h1>
<h2 id="-">为什么要学习对象</h2>
<pre><code class="lang-JavaScript">    //为什么要学习对象
    function printStudentInfo(name,age,address.........){
        console.log(name);
        console.log(age);
        console.log(address);
        console.log(.....);
    }

    /*数组可以把所有的数据存储起来，方便传递;(存方便，取不方便)

    为了存数据方便，取数据方便，我们引入了对象这个数据;
        用空间换时间;（占位置大了，但是存值和获取值快了）
        用时间换空间;（占位置小了，但是获取值慢了）*/
</code></pre>
<h2 id="-">定义对象和使用对象</h2>
<pre><code class="lang-javascript">     //对象的定义方法：对象是无序存储；
    1.字面量法;
       var obj1 = {name:&quot;张三&quot;,age:18};//数组是[]；
       console.log(obj1);
    2.构造函数法;
       var obj2 = new Object();//这是一张白纸;等待着我们像上
       面输出内容;
       console.log(obj2);
    对象的组成：属性和方法;
            属性:对象里面的变量；
            方法:对象里面的函数；

    var stu = new Object();空白对象;
    绑定属性和方法;
    stu.name = &quot;张三&quot;;
    stu.age = 18;

    stu.sayHi = function () {
        console.log(&quot;大家好，我叫张三！！！&quot;);
    }

    调用属性和方法
    console.log(stu.name);
    console.log(stu.age);
    console.log(stu.sayHi);
    stu.sayHi();不要打印，直接调用;
    console.log(stu);
</code></pre>
<h2 id="-">对象的属性绑定</h2>
<pre><code class="lang-javascript">   对象的属性绑定：两种方法;


    var stu = new Object();
    1.直接点属性;         对象.属性;    优点：快速，方便;    缺点：不灵活;
    stu.name = &quot;张三&quot;;


    2.类似数组绑定;       对象[属性];    优点：灵活;    缺点：慢，不方便;
        []可以放变量，也可以放字符串;
    var aaa = &quot;age&quot;;
    stu[aaa] = &quot;李四&quot;;
</code></pre>
<h2 id="-">自定义对象（单个对象）</h2>
<pre><code class="lang-javascript">      需求：我们希望自己能够按照自己想要的自定义一个对象，这样将
    来就能按照自己想要的进行操作;

        思路：创建一个空白对象，然后自己安装需要绑定属性和方法;

    var stu = new Object();//空白对象;

    //绑定属性;
    stu.name = &quot;张三&quot;;
    stu.age = 18;

    stu.study = function () {
        console.log(&quot;扶我起来，我还可以在..敲一段...代码....&quot;);
    }
    stu.sleep = function () {
        console.log(&quot;不行了，困死了，我先睡了，你们继续......&quot;);
    }

    console.log(stu);
    console.log(stu.name);
    console.log(stu.age);
    stu.study();
    stu.sleep();
</code></pre>
<h2 id="-">自定义对象（多个对象）</h2>
<pre><code class="lang-javascript">
    需求：我们希望自己能够按照自己想要的自定义一个对象，这样将
    来就能按照自己想要的进行操作;
            想要多个对象也可以创建;不用一个一个创建了;

        for循环创建: 容易层叠，属性值的改变也不方便;(不好)
        利用函数封装：把需要改变的值设置为变量，然后通过封装函
    数的调用;


    把逻辑用函数包起来:

    function createStudent(name,age){
        var stu = new Object();//空白对象;
        //绑定属性;
        stu.name = name;
        stu.age = age;

        stu.study = function () {
            //this：代指函数调用者！！！
            console.log(this.name+&quot;:扶我起来，我还可以在&quot; +
                    &quot;..敲一段...代码....&quot;);
        }
        stu.sleep = function () {
            //this：代指函数调用者！！！
            console.log(this.name+&quot;:不行了，困死了，我先睡了，&quot; +
                    &quot;你们继续......&quot;);
        }
        //函数内部的变量，外部如果想要使用，必须return;
        return stu;
    }

    var stu1 = createStudent(&quot;张三&quot;,18);
    var stu2 = createStudent(&quot;李四&quot;,19);

    console.log(stu1);
    console.log(stu2);

    stu1.study();
    stu2.study();
</code></pre>
<h2 id="-">自定义对象（对象）</h2>
<pre><code class="lang-javascript">    需求：需要使用对象的时候用要给方法一调用就会有要给对象;

    用方法把创建对象绑定属性的内容封装起来
    function createStudent(name,age){
        //创建一个空白对象
        var stu = new Object();
        //通过属性和方法的绑定让他看起来是一个学生
        stu.name = name;
        stu.age = age;
        stu.sayHi = function () {
            //this代指函数调用者;
            console.log(&quot;我叫&quot;+this.name);
        }
        //创建完毕，绑定好的对象，外部想要使用，必须返回
        return stu;
    }

    var stu1 = createStudent(&quot;张三&quot;,18);
    var stu2 = createStudent(&quot;李四&quot;,19);

    console.log(stu1);
    console.log(stu2);

    stu1.sayHi();
    stu2.sayHi();
</code></pre>
<h1 id="-">对象的使用</h1>
<h2 id="-">对象属性的遍历和删除</h2>
<pre><code class="lang-JavaScript">     如果一个对象里面只有属性，没有方法，而且不需要定义类型；一般用字面量定义；
        属性带不带引号都可以；
    var obj = {&quot;width&quot;:&quot;100px&quot;,&quot;height&quot;:&quot;200px&quot;,top:100,left:100};


    console.log(obj.length);//undefined;对象没有length属性；遍历对象不能用for循环
    1.遍历对象中的属性；
        利用for...in...循环遍历;因为for...in...不要想指定次数；
    for(var i in obj){
        console.log(i);//obj中的属性；
        console.log(obj[i]);//obj中i属性对应的属性值；
        console.log(&quot;-----&quot;);
    }

    2.删除属性；(了解)
    console.log(obj);
    delete obj.width;
    delete obj.top;
    console.log(obj);
</code></pre>
<h2 id="this-new-">this和new做了什么</h2>
<pre><code class="lang-javascript">        构造函数和普通函数;
        1.构造函数用来创建对象用的;
        2.构造函数首字母大写;

        一.new 做了这四点：
        a.new会在内存中创建一个新的空对象
        b.new 会让this指向这个新的对象
        c.执行构造函数  目的：给这个新对象加属性和方法
        d.new会返回这个新对象

        二.this 也做了四点;（this在new使用的情况下，就是指的被创建的新对象）
        a.函数在定义的时候this是不确定的，只有在调用的时候才可以确定(不需要知道)
        b.一般函数直接执行，内部this指向全局window（BOM）(不需要知道)
        c.函数作为一个对象的方法，被该对象所调用，那么this指向的是该对象（new做的）
        d.构造函数中的this其实是一个隐式对象，类似一个初始化的模型，
          所有方法和属性都挂载到了这个隐式对象身上，后续通过new关键字来调用，
          从而实现实例化

        注意：this在不使用new的情况下，代指函数的调用者！！！
</code></pre>
<h2 id="-json">对象的使用-json</h2>
<pre><code class="lang-javascript">  json: js的对象表示法;
     JavaScript Object Notation: js中对对象的一种表示形式；

        json是对象的一个子集或者一部分;

    var json = {&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:18};//一般json的属性都是字符串;
        //键值对：  key:value,k1:v1....

    var obj = {0:&quot;张三&quot;,1:&quot;李四&quot;,2:&quot;王五&quot;,length:3};
    console.log(json);
    console.log(obj);


    for(var k in json){
        console.log(k);//属性
        console.log(json[k]);//属性值
    }

    js中能够自定义对象，但是无法自定义类型；   都是基于object创建的;

    var stu = new Object();
    stu.name = 1;
    stu.age = 2;

    console.log(stu);
    console.log(typeof stu);
    console.log(&quot;------&quot;);


    function Teacher(name,age){
        this.name = name;
        this.age = age;
    }

    var t1 = new Teacher(&quot;吕超&quot;,30);
    console.log(t1);
    console.log(typeof t1);//基于object造出来的对象；

    //instanceof:可以查看使用那个构造函数创建出来的;
        //用法： A instanceof B;A是否是B构造函数创建的；
    console.log(stu instanceof Object);//所有对象都是基于object，所以用Object都是true;
    console.log(t1 instanceof Array);
    console.log(t1 instanceof Teacher);
</code></pre>
<h2 id="-">自定义对象（构造函数）</h2>
<pre><code class="lang-JavaScript">
 //需求：需要使用对象的时候用要给方法一调用就会有要给对象;
            //方法创建的缺点：1.和js底层不太一样;  new Object(); .... createStudent();
            //方法创建的缺点：2.代码太多


//new Object();

    //构造函数创建对象封装
    function Student(name,age){//构造函数首字母大写;
        //1.创建一个空白对象,new帮我们做了！！！
    //  var stu = new Object();
        //通过属性和方法的绑定让他看起来是一个学生

        //3.没有stu创的空白对象了；用this，new把this指向当前对象了
        this.name = name;
        this.age = age;
        this.sayHi = function () {
            //this代指函数调用者;
            console.log(&quot;我叫&quot;+this.name);
        }
        //创建完毕，绑定好的对象，外部想要使用，必须返回
        //2.new帮我们返回对象了
    //  return stu;
    }

    //构造函数必须用new调用才会产出新对象(对象实例)
    var stu1 = new Student(&quot;张三&quot;,18);
    var stu2 = new Student(&quot;李四&quot;,19);

    console.log(stu1);
    console.log(stu2);

    stu1.sayHi();
    stu2.sayHi();
</code></pre>
<h2 id="-">简单和复杂数据类型存储问题</h2>
<pre><code class="lang-JavaScript">     数据类型：简单数据类型(值类型)和复杂数据类型(引用);

        简单数据类型(值类型): string,number,boolean,undefined;
        复杂数据类型(引用):   object,function


    在内存中：简单数据类型存储在栈中，复杂数据类型存储在堆中；
</code></pre>
<h2 id="-">为什么要学构造函数自定义对象</h2>
<pre><code class="lang-JavaScript">   JS里面分为两类对象：
    1.自定义的对象;    学生构造函数，老师构造函数，汽车构造函数，飞机构造函数....
    2.内置对象;        Array,Date,Math,String,Error,RegExp...

    内置对象的属性和方法的学习非常方便，因为我们都可以自定义对象了，学习不成问题！

    js是一门基于对象的语言;都是基于object创建出来的对象；
    var stu1 = new Student(&quot;张三&quot;);
    console.log(stu1);
    console.log(typeof stu1);

    function Student(name){
        this.name = name;
    }
</code></pre>
<h2 id="-">简单和复杂数据类型值传递问题</h2>
<pre><code class="lang-JavaScript">   数据类型：简单数据类型(值类型)和复杂数据类型(引用);

        简单数据类型(值类型): string,number,boolean,undefined;
        复杂数据类型(引用):   object,function

    传递：
        1.简单数据类型传值(数值)；
        2.复杂数据类型传址(地址)；值传递容易操作同一片内存空间；

    改其中一个另一个不会被修改；
    var a = 111;
    var b = a;
    a = 222;
    console.log(a);
    console.log(b);

    改其中一个另一个也会被修改；
    var stu1 = new Stu(&quot;张三&quot;,18);
    var stu2 = stu1;
    stu1.name = &quot;李四&quot;;
    console.log(stu1);
    console.log(stu2);

    cosnole.log(stu1 === stu2);//复杂数据类型比较的是地址；

    function Stu(name,age){
        this.name = name;
        this.age = age;
    }
</code></pre>
<h2 id="-">遍历对象的属性</h2>
<pre><code class="lang-javascript">    对象的定义两种方法：1.字面量；    2.构造函数;

    对象属性和值的遍历;(获取每一个属性和对应的值)
        属性的值也是对象;
    var obj = {&quot;name&quot;:&quot;张三&quot;,age:18,sayHi:function(){console.log(111)}};

    for循环遍历

    对象没有length属性，所有不能用普通的for循环;
    console.log(obj.length);
    for(var i=0;i&lt;obj.length;i++){
        console.log(i);
    }

    for...in...  不需要通过length属性控制循环的次数，
      for循环本身通过检测对象里面内容的个数决定循环的次数;
    var arr = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;];
    for(var i in arr){//遍历数组，不需要知道次数;
        console.log(i);
        console.log(arr[i]);
    }

    for(var k in obj){
        console.log(k);//obj中的属性;
        console.log(obj[k]);//obj中的属性对应的值;
    }

    var arr = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;];
    arr[9] = 111;
    console.log(arr);

    for(var i=0;i&lt;arr.length;i++){
        console.log(arr[i]);
    }

    for...in...不会遍历undefined的内容;
    for(var i in arr){
        console.log(arr[i]);
    }
</code></pre>
<h2 id="-">面试题</h2>
<pre><code class="lang-javascript">     简单数据类型(值类型)和复杂数据类型(引用)值传递面试题
            简单数据类型做实参传数值；
            复杂数据类型做实参传地址；

    var num = 111;

    fn(num);
    console.log(aaa);//报错；
    console.log(num);//111;不是你好；

    function fn(aaa){//形参也是局部变量
        aaa = &quot;你好&quot;;//num将值传递给aaa,num本身还是111；
    }

    var stu1 = new Stu(&quot;张三&quot;);

    fn(stu1);

   console.log(obj.name);//外部没有obj，所有报错；
    console.log(stu1.name);//复杂数据类型传递的是地址；

    function Stu(name){
        this.name = name;
    }

    function fn(obj=hash:0x234345345){//形参也是局部变量
        obj.name = &quot;李四&quot;;//obj接受到了stu1的内存地址，公用一片内存空间一个修改，内存就被修改了
    }

    简单数据类型：全局变量想要修改,直接修改，不要进行参数传递；
                  传递过去，外部变量也不会被修改，因为简单数据类型传值；
    复杂数据类型：值传递的时候，要注意，传递的是地址，一个被修改，另一个也会同步修改；
                  如果不想让一个对象被修改，赋值前，要重新开辟空间保存；
</code></pre>
<h2 id="-">对象属性的增删改判</h2>
<pre><code class="lang-javascript">    1.属性的添加(修改)
    2.属性的判断
    3.属性的删除

    var obj = {&quot;name&quot;:&quot;张三&quot;,age:18};
    console.log(obj);

    1.属性的添加
    obj.address = &quot;三里屯&quot;;
    //修改
    obj.address = &quot;四里屯&quot;;
    console.log(obj);

    2.属性的判断
    console.log(&quot;age&quot; in obj);//obj这个值中是否存在一个age属性
    console.log(&quot;aaa&quot; in obj);//obj这个值中是否存在一个age属性

    //3.属性的删除
    delete obj.name;
    console.log(obj);
</code></pre>
<h1 id="-">内置对象</h1>
<h2 id="js-">js的内置对象和学习方法</h2>
<pre><code class="lang-javascript">    手机：自带软件和下载软件；
    电脑：自带软件和下载软件；

    js:  自带的对象和自定义对象；
            js内部自带的对象就是内置对象;   数组，Date，Math,Stirng......

    js内置对象：1.静态对象;    2.实例对象（new 创建的对象(多)）
            都是有属性和方法；

    学习方法：
           ①.w3cschool: 官网查看;   方法比较少；
        ②.老师，自己去网上下载离线文档;
        ③.MDN;  前端学习主要查看网站；

    学习内置对象的属性和API的时候，注意以下几点；
        1.调用者;(注意)
        2.参数;(注意)
        3.返回值;(重要)
        4.功能;(重要)
</code></pre>
<h2 id="math-">Math对象的一些方法</h2>
<pre><code class="lang-javascript">        Math.PI                        // 圆周率
    Math.random()                // 生成随机数
    Math.floor()/Math.ceil()     // 向下取整/向上取整
    Math.round()                // 取整，四舍五入
    Math.abs()                    // 绝对值
    Math.max()/Math.min()         // 求最大和最小值

    Math.sin()/Math.cos()         // 正弦/余弦
    Math.power()/Math.sqrt()     // 求指数次幂/求平方根

    Math.PI                        // 圆周率
    console.log(Math.PI);

    Math.random()                // 生成随机数    [0,1);能取0，不能取1；(包左不包右)
    console.log(Math.random());
    console.log(parseInt(Math.random()*101));//[0-100]
    console.log(50+parseInt(Math.random()*51));//[50-100]


    Math.floor()/Math.ceil()     // 向下取整/向上取整
    console.log(Math.floor(1.00000));//1;
    console.log(Math.floor(1.99999));//1;

    console.log(Math.ceil(1.00000));//1;
    console.log(Math.ceil(1.00001));//2;

    console.log(Math.floor(-1.1));//-2;向下取整，变小；
    console.log(Math.ceil(-1.1));//-1;向上取整，变大；

    Math.round()                // 取整，四舍五入
        console.log(Math.round(1.4));//1
        console.log(Math.round(1.5));//2
        //负数五舍六入；
        console.log(Math.round(-1.4));//-1
        console.log(Math.round(-1.5));//-1
        console.log(Math.round(-1.6));//-2

    Math.abs()                    // 绝对值：正的变正的，负的也变正的
    console.log(Math.abs(-111));
    console.log(Math.abs(111));

    Math.max()/Math.min()         // 求最大和最小值
    console.log(Math.max(1,2,3,5,6));
    console.log(Math.min(1,2,3,4,5,6));

    Math.sin()/Math.cos()         // 正弦/余弦（了解）
            Math.PI/2 === 90°；
    console.log(Math.sin(Math.PI/2/3));

    Math.pow()/Math.sqrt()     // 求指数次幂/求平方根
        console.log(Math.pow(2,4));//Math.pow(A,B);A的B次方；
        console.log(Math.sqrt(9));//为参数开平方；
</code></pre>
<h2 id="-json">对象的使用-json</h2>
<pre><code class="lang-javascript">     json: js对象表示法;
            (JavaScript Object Notation, JS 对象标记)

        他和对象几乎相同;   json是对象的一部分;
            json中的属性要求都是字符串;

        var obj = {&quot;name&quot;:&quot;张三&quot;,age:18};
        var json = {&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:18};

        但是还是有很多人，把属性不是字符串的内容也叫json;
            {name:111,age:222};   勉强同意;

        在低版本的jQuery中（1.7），ajax进行数据传递的时候，属性必须带有“”;
</code></pre>
<h2 id="-">简单和复杂数据类型值传递问题</h2>
<pre><code class="lang-javascript">    1.存储问题：
            简单数据类型：存储在栈中;
            复杂数据类型：存储在堆中;

        2.赋值传递问题;(重点)
            简单数据类型: 传递数据的时候传递的是数值;(值)
            复杂数据类型: 传递数据的时候传递的是内存地址;(址)

        简单数据类型: 传递数据的时候传递的是数值;(值)
        var num1 = 111;
        var num2 = num1;
        num1 = 222;
        console.log(num1);//222
        console.log(num2);//111

        复杂数据类型: 传递数据的时候传递的是内存地址;(址)
        var obj1 = {&quot;name&quot;:&quot;张三&quot;,age:18};
        var obj2 = obj1;
        obj1.name = &quot;李四&quot;;
        console.log(obj1);//李四
        console.log(obj2);//李四
</code></pre>
<h2 id="-">面试题</h2>
<pre><code class="lang-javascript">      1.简单数据类型传递
        var num = 111;

        fn(num);
        alert(num);//简单数据类型传递的是数值,所以num的值依旧是111;

        //怎么修改简单数据类型的全局变量：直接在函数中修改不要传变量;

        function fn(aaa){//aaa在fn执行的时候是111；
            aaa = 222;//把aaa的值改为的222；
        }

        2.复杂数据类型值传递
        var stu = {&quot;name&quot;:&quot;张三&quot;};

        //调用
        fn(stu);//复杂数据类型值传递的时候，传递的是内存中的地址;
        console.log(stu);

        function fn(obj){//obj在函数fn执行的时候和stu公用一片内存空间;
            obj.name = &quot;李四&quot;;//obj该name，stu的那么同时也会修改，因为他们对应的是一个对象;
        }

        3.复杂数据类型比较的是地址;
            {}  和   new Object();  是一样的;
        var a = {};//每生成一个新对象，就是开辟一片新空间;
        var b = {};//每生成一个新对象，就是开辟一片新空间;
        console.log(a == b);
</code></pre>
<h2 id="math-">Math原理</h2>
<pre><code class="lang-javascript">     //Math对象原理和max；(最小值自己做)
    var OurMath = {
        max: function () {
            //   alert(1);
            //最大值的逻辑(写几个都行---argumentsZ)
            var val = arguments[0];
            //for循环判断
            for(var i=1;i&lt;arguments.length;i++){
                if(arguments[i] &gt; val){
                    val = arguments[i];
                }
            }

            //返回最大值；
            return val;
        }
    };

    OurMath.max();

    console.log(OurMath.max(1,22,3));
</code></pre>
<h2 id="maht-3-">Maht对象案例（3个）</h2>
<pre><code class="lang-javascript">       - 求10-20之间的随机数
    for(var i=0;i&lt;100;i++){
        console.log(10+parseInt(Math.random()*11));
    }

    - 随机生成颜色rgb(0,0,0);    0-255;
    for(var i=0;i&lt;10;i++){
        var num1 = parseInt(Math.random()*256);
        var num2 = parseInt(Math.random()*256);
        var num3 = parseInt(Math.random()*256);
        //rgb(0,0,0);
        var str = &quot;rgb(&quot;+num1+&quot;,&quot;+num2+&quot;,&quot;+num3+&quot;)&quot;;
        console.log(str);
        document.body.bgColor = str;
    }

    定义一个数组；0-9和a-f;   随机六次做数组索引值；  然后用#开头链接起来；

    - 模拟实现max()/min()

    var MyMath = new Object();
    MyMath.min = function () {
        var val = arguments[0];
        for(var i=1;i&lt;arguments.length;i++){
            if(arguments[i]&lt;val){
                val = arguments[i];
            }
        }
        //返回
        return val;
    }

    console.log(MyMath.min(1,-2,4));


    var MyMath = {
        min: function () {

        }
    };

var aaa = {
    name:&quot;张三&quot;,
    age:18,
    sayHi: function(){
        console.log(111)
    }
};
</code></pre>
<h2 id="date-">Date对象的一些方法</h2>
<pre><code class="lang-javascript">      日期对象Date: 实例对象；  使用的时候需要new；
    var aaa = new Date();
    console.log(aaa);

    创建方法
    常用
    var date1 = new Date();
    设定制定时间：（兼容最强）
    var date2 = new Date(&quot;2016/01/27 12:00:00&quot;)
    不常用：
    var date3 = new Date(&#39;Wed Jan 27 2016 12:00:00 GMT+0800 (中国标准时间)&#39;);
    var date4 = new Date(2016, 1, 27);

    console.log(date1);
    console.log(date2);
    console.log(date3);
    console.log(date4);

    如果想要获取具体的时间那么需要使用固定的方法进行获取；
    var date = new Date();

    console.log(date.getDate()        );//获取日 1-31
    console.log(date.getDay ()        );//获取星期 0-6（0代表周日）
    console.log(date.getMonth ()      );//获取月 0-11（1月从0开始）
    console.log(date.getFullYear ()      );//获取完整年份（浏览器都支持）
    console.log(date.getHours ()      );//获取小时 0-23
    console.log(date.getMinutes ()      );//获取分钟 0-59
    console.log(date.getSeconds ()      );//获取秒  0-59
    console.log(date.getMilliseconds());//获取毫秒 （1s = 1000ms）
    console.log(date.getTime ()          );//返回累计毫秒数(从1970/1/1午夜)

    var date1 = Date.now();
    var date2 = +new Date();
    var date3 = new Date().getTime();
    var date4 = new Date().valueOf();

    console.log(date1)
    console.log(date2)
    console.log(date3)
    console.log(date4)
</code></pre>
<h2 id="date-3-">Date对象的案例（3个）</h2>
<pre><code class="lang-javascript">     1.把今天的时间打印到控制台;
    var now = new Date();

    var year = now.getFullYear();
    var month = now.getMonth();
    var day = now.getDate();//日期
    var week = now.getDay();//星期

    var arr = [&quot;日&quot;,&quot;一&quot;,&quot;二&quot;,&quot;三&quot;,&quot;四&quot;,&quot;五&quot;,&quot;六&quot;];
    console.log(&quot;今天是&quot;+year+&quot;年&quot;+(month+1)+&quot;月&quot;+day+&quot;日 星期&quot;+arr[week]);

    2.格式化时间
    var now = new Date();
    var aaa = formatTime(now);
    console.log(aaa);

    function formatTime(timer){
        //从里面吧年月日，时分秒；
        var year = timer.getFullYear();
        var month = timer.getMonth()+1;//月份从0开始，所以加1；
        var day = timer.getDate();

        var hour = timer.getHours();
        var minute = timer.getMinutes();
        var second = timer.getSeconds();

        if(month&lt;10){
            month = &quot;0&quot;+month;
        }
        day = day&lt;10?&quot;0&quot;+day:day;
        hour = hour&lt;10?&quot;0&quot;+hour:hour;
        minute = minute&lt;10?&quot;0&quot;+minute:minute;
        second = second&lt;10?&quot;0&quot;+second:second;
        //格式化好的时间返回
        return year+&quot;/&quot;+month+&quot;/&quot;+day+&quot; &quot;+hour+&quot;:&quot;+minute+&quot;:&quot;+second;
    }

    3.计算时间差，返回相差的天/时/分/秒(距离七夕)
            求总时间差，然后换算成：天/时/分/秒

    目标事件和当前的毫秒值时间差；
    var nowTime = new Date(&quot;2017/8/12 16:50:50:998&quot;).getTime();
    var nowTime = new Date().getTime();
    var futureTime = new Date(&quot;2017/8/28 00:00:00&quot;).getTime();
    var zsj = futureTime-nowTime;

    console.log(zsj);
    //转换成天,时分秒，毫秒；
    var day = parseInt(zsj/1000/60/60/24);
    var hour = parseInt(zsj/1000/60/60%24);
    var minute = parseInt(zsj/1000/60%60);
    var second = parseInt(zsj/1000%60);
    var ms = zsj%1000;

    day = day&lt;10?&quot;0&quot;+day:day;
    hour = hour&lt;10?&quot;0&quot;+hour:hour;
    minute = minute&lt;10?&quot;0&quot;+minute:minute;
    second = second&lt;10?&quot;0&quot;+second:second;
    //毫秒值特殊处理；
    if(ms&lt;10){//小判断小于10，在判断小于100；因为小于10同样小于100；
        ms = &quot;00&quot;+ms;
    }else if(ms &lt; 100){
        ms = &quot;0&quot;+ms;
    }

    console.log(&quot;距离七夕节，还有&quot;+day+&quot;天&quot;+hour+&quot;小时&quot;+minute+&quot;分钟&quot;+second+&quot;秒钟&quot;+ms+&quot;毫秒&quot;);
</code></pre>
<h2 id="-">数据类型和回调函数</h2>
<pre><code class="lang-javascript">     1.简单和复杂数据类型值传递；
        传递：
            a.简单数据类型传值(数值)；
            b.复杂数据类型传址(地址)；值传递容易操作同一片内存空间；

    var num1 = 111;

    fn(num1);
    console.log(num1);//111;
    console.log(aaa);//报错；局部变量外部访问不到；

    function fn(aaa){
        aaa = 222;
        //要想改变全局变量num1或者简单数据类型，直接在这里改动；
        //  num1 = 333;
    }

    var stu1 = new Stu(&quot;张三&quot;);
    var stu2 = stu1;
    fn(stu1);
    console.log(stu1.name);//复杂数据类型传递值；stu1和stu2公用一个内存空间；
    console.log(stu2.name);//复杂数据类型传递值；stu1和stu2公用一个内存空间；
    console.log(obj.name);//报错；

    function Stu(name){
        this.name = name;
    }
    function people(name){
        this.name = name;
    }
    //函数内部的局部变量，执行的时候，才在内存中开辟，执行完毕就回收；
    function fn(obj){
        // obj = new people(&quot;王五&quot;);//重新分配内存空间；
        obj.name = &quot;李四&quot;;
        //  obj = new people(&quot;王五&quot;);//重新分配内存空间；
    }



    2.回调函数：函数作为参数进行传递和调用
        回调函数一般用于定义一种规则；

    演示1
    a(b);//b把地址赋值demo，然后demo执行了，b同样的内存空间中；

    function a(demo){//demo一定是回调函数，以为下面demo后面带括号；
        demo();
    }
    function b(){
        alert(&quot;b方法被执行了！&quot;);
    }


    演示2
    a(111,222,getSum);//把111和222按照getSum这个回调函数，进行调用


    function a(n1,n2,demo){
        var num = demo(n1,n2);//demo说怎么算，就怎么算；这就是回调函数定义的规则；
        alert(num);
    }

    function getSum(num1,num2){
        var aaa = num1+num2;
        return aaa;
    }

    演示3
        回调函数，是定义一种规则；

    a(10,5,test1);//test1不带括号是整个函数，带括号就是执行函数了
    a(10,5,test2);//test2不带括号是整个函数，带括号就是执行函数了
    a(10,5,test3);//test3不带括号是整个函数，带括号就是执行函数了
    a(10,5,test4);//test4不带括号是整个函数，带括号就是执行函数了



    function a(n1,n2,demo){
        var num = demo(n1,n2);
        alert(num);
    }

    四个测试函数；(四则运算),这四个方法只能做回调函数，但是无法调用回调函数；
    function test1(num1,num2){
        return num1+num2;
    }
    function test2(num1,num2){
        return num1-num2;
    }
    function test3(num1,num2){
        return num1*num2;
    }
    function test4(num1,num2){
        return num1/num2;
    }
</code></pre>

          	</article>
        </div>
		</div>
  </body>
</html>
<script type="text/javascript" src="toc/js/jquery-1.4.4.min.js"></script>
<script type="text/javascript" src="toc/js/jquery.ztree.all-3.5.min.js"></script>
<script type="text/javascript" src="toc/js/ztree_toc.js"></script>
<script type="text/javascript" src="toc_conf.js"></script>
<script type="text/javascript" src="toc/js/highlight.pack.js"></script>

<SCRIPT type="text/javascript" >
<!--
$(document).ready(function(){
    $('pre code').each(function(i, block) {
        hljs.highlightBlock(block);
    });
    var css_conf = eval(markdown_panel_style);
    $('#readme').css(css_conf)
    
    var conf = eval(jquery_ztree_toc_opts);
		$('#tree').ztree_toc(conf);

		
  		$('#readme a:eq(0)').addClass('list-group-item active');
});
//-->
//

</SCRIPT>