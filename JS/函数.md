# 首页
[首页](../index.html)

# 函数
##  函数的定义和使用
```JavaScript
	什么是函数：可以重复执行的代码块！
	
	循环语句也可以重复执行，为什么还要使用函数？？？
	    1.逻辑调用不能省略；函数调用更加简便（  函数名()  ）
	    2.循环语句大部分时候在循环执行;函数可以更灵活的修改其中的一部分值;
	
	函数：哪里需要哪里调用，灵活;
	
	函数的定义方法：2种;
	
	第一种：字面量;
	函数不调用不执行;     调用：函数名();
	fn();//调用可以在定义之前
	function fn(){
	    alert("hello world!!!");
	}
	
	第二种：变量赋值;
	var fun = function(){
	    alert(222);
	}
	
	//只能在下面调用；
	fun();
```

## 函数的参数
```JavaScript
    参数：1.形参；   2.实参;
    1.形参：形式上参与运算的变量;
    2.实参：实际上参与运算的值;
    为了增加函数的功能性，和程序员的交互性，和可拓展性;给他增加变量；
        fn(333,222);//333和222就是实参；
        function fn(a,b){//a和b就是形参;
            alert(a+b);
        }
    总结：形参是给实参占位置;
    形参和实参个数不符合;
        1.实参多;写多了，参数传多了！ 传多了，我们不用！！！
        2.实参正好;无意义，正常执行;
        3.实参少;没有传的用undefined补充！
    
    1.实参多;写多了，参数传多了！ 传多了，我们不用！！！
         fn(1,2,3,4,5,6);//传多了，我们不用！！！
    2.实参正好;无意义，正常执行;
         fn(1,2);
    3.实参少;没有传的用undefined补充！
        fn(1);
        function fn(a,b){
            alert(a+b)
            console.log(a);
            console.log(b);
        }
    js中没有方法重载：两个参数和三个参数和...，都一样，后面的方法把前面的方法覆盖掉;
        fn(){
    
        }
        fn(a,b){
    
        }
```

## 函数参数案例
```JavaScript
	1.求1-n之间所有数的和
	2.求n-m之间所有数的和
	3.圆的面积
	4.求2个数中的最大值
	5.求3个数中的最大值
	
	求1-n之间所有数的和
	
	getSum(10);
	function getSum(n){
	    var sum = 0;
	    for(var i=1;i<=n;i++){
	        sum += i;
	    }
	    alert(sum);
	}
	
	求n-m之间所有数的和
	getSum(9,10);
	function getSum(n,m){
	    var sum = 0;
	    for(var i=n;i<=m;i++){
	        sum+=i;
	    }
	    alert(sum);
	}
	
	圆的面积
	    公式： area = 3.14*r*r;
	getArea(10);
	function getArea(r){
	    var area = 3.14*r*r;
	    alert(area);
	}
	
	求2个数中的最大值
	getMaxOfTwo(3,2);
	function getMaxOfTwo(num1,num2){
	//     if(num1>num2){
	//         alert(num1);
	//     }else{
	//         alert(num2);
	//     }
	    //三元运算符
	    var max = num1>num2?num1:num2;
	    alert(max);
	}
	
	求3个数中的最大值
	getMaxOfThree(4,6,3);
	function getMaxOfThree(a,b,c){
	两两比较，前两个比较完毕在比较后两个;
	if(a>b){
	//a大，然后在和c比较;
	if(a>c){
	    //a>b&&a>c;
	    alert(a);
	}else{
	    //c>a>b
	    alert(c);
	}
	}else{
	//b>a的；和c比较
	if(b>c){
	    //b>a&&b>c;
	    alert(b);
	}else{
	    //c>b>a;
	    alert(c);
	}
	}
	
	优化1: 三元运算符;
	var max = a>b?a:b;
	max = max>c?max:c;
	alert(max);
	
	优化2: 三元运算符;
	var max = a>b?a:b;
	max = max>c?max:c;
	
	var max = a>b?a:b>c?a>b?a:b:c
	var max = (a>b?a:b)>c?(a>b?a:b):c;
	alert(a>b?a:b>c?a>b?a:b:c);
	}
```


## 函数的返回值
```JavaScript
       函数的返回值：函数内部的变量或者值外部无法使用所以需要返回;
        函数通过运算出来的结果，如果外部需要使用请通过return进行返回，外部才能够使用;
        
        var num = fn();
        //    alert(aaa);
        alert(num);
        
        function fn(){
            var aaa = 111;
            //如果想要让外部使用的话，通过关键字return进行返回，外部才能接收;
            return aaa;
        }
        
        函数返回值注意点：
        如果函数没有显示的使用 return语句 ，那么函数有默认的返回值：undefined
        如果函数使用 return语句，那么跟再return后面的值，就成了函数的返回值
        如果函数使用 return语句，但是return后面没有任何值，那么函数的返回值也是：undefined
        函数使用return语句后，这个函数会在执行完 return 语句之后停止并立即退出，也就是说return后面的所有其他代码都不会再执行。
        
        fn();
        function fn(){
            return;//return有切断函数的功能;下面不在执行;
            console.log(1);
            console.log(2);
            console.log(3);
        }
```

## 函数返回值案例
```JavaScript
        1.求一组数中的最大值
        2.求一组数中的最小值
        3.求阶乘
        4.求1!+2!+3!+....+n!

        1.求一组数中的最大值
            var arr = [1,2,3,4,5];

            //测试
            var aaa = getMax(arr);
            alert(aaa);
            //封装一个函数，获取最大值;
            //参数: 数组    返回值：最大值;
            function getMax(array){
                //吧数组中的第一个设置为最大值
                var max = array[0];
                //通过for循环比较
                for(var i=1;i&lt;array.length;i++){
                    if(max < array[i]){
                        max = array[i];
                    }
                }
                //返回最大值
                return max;
            }

        3.求阶乘
            5! = 5*4*3*2*1;
            4! = 4*3*2*1;
            ....

             alert(getJC(4));

              function getJC(num){
                  var product = 1;
                  for(var i=1;i<=num;i++){
                      product*=i;
                  }
                  //返回
                  return product;
              }

        2.求一组数中的最小值
              var arr = [-1,-2,-3,-4,-5];

            //测试
                 var aaa = getMin(arr);
                 alert(aaa);
            //拓展
            alert(getMin(arr));//打印的就是函数的返回值；
                    //执行函数getMin();并把返回值扔在这里
            //封装
            function getMin(a){
                var min = a[0];
                //for循环判断
                for(var i=1;i< a.length;i++){
                    if(min > a[i]){
                        min = a[i];
                    }
                }
                //返回值
                return min;
            }

           4.求1!+2!+3!+....+n!
            求阶乘的和;(同级函数可以嵌套使用)
                function getJCSum(n){
                    //求和;
                    var sum = 0;
                    //for循环
                    for(var i=1;i<=n;i++){
                        //阶乘的和;
                        sum += getJC(i);//i取值，第一轮是1，第二轮是2，第三轮是3....
                    }
                    return sum;
                }

            //测试
            alert(getJCSum(5));
```


## 函数的返回值问题
```JavaScript
       	1.函数如果没有return和有return没有值返回的都是  undefined;
        2.return可以切断函数；
        3.一个函数中不一定只有一个return,但是只能执行一个return;

            function getMax(n1,n2){
                if(n1>n2){
                    return n1;
                }
                return n2;
            }
```


## 函数的案例
```JavaScript
	1.求斐波那契数列Fibonacci中的第n个数是多少？      1 1 2 3 5 8 13 21...
        2.翻转数组，返回一个新数组
        3.对数组排序，从小到大
        4.判断一个数是否是素数(又叫质数，只能被1和自身整数的数)
        5.输入一个年份，判断是否是闰年[闰年：能被4整数并且不能被100整数，或者能被400整数]

        1.求斐波那契数列Fibonacci中的第n个数是多少？
          1 1 2 3 5 8 13 21...

        alert(FBNQSL(12))的
        //封装一个数列，返回第几个数值;
        function FBNQSL(n){
        //        if(n<1){
        //            return "无意义！";//不让下面代码执行
        //        }
            //定义两个变量
            var n1 = 1;
            var n2 = 1;
            //for循环从第3个开始，轮回
            for(var i=3;i<=n;i++){
                //第三项开始当前项等于前两项之和;先存储好后一项
                var temp = n2;
                n2 = n1+n2;
                n1 = temp;
            }

            //return  后一个变量
            return n2;
        }

        2.翻转数组，返回一个新数组
        var arr = [1,2,3];
        console.log(arr);

        //测试
        console.log(rev1(arr));

        function rev1(array){
            var newArr = [];
            //反向遍历正向添加;
            for(var i=array.length-1;i>=0;i--){
                newArr[newArr.length] = array[i];
            }
            //把新创建的数组返回
            return newArr;
        }

        3.对数组排序，从小到大
            冒泡排序
        var arr = [3,2,4,6,1,5];
        console.log(bubble(arr));
        function bubble(a){
            //外循环控制轮数，内循环控制次数，都是元素个数-1；
            for(var i = 0;i< a.length-1;i++){
                //轮数优化;变量定义到两个for循环之间
                var bool = true;
                for(var j=0;j< a.length-1-i;j++){
                    //满足条件交换位置
                    if(a[j] > a[j+1]){
                        var temp = a[j];
                        a[j] = a[j+1];
                        a[j+1] = temp;
                        //任何两个元素交换位置，都不能跳出循环了
                        bool = false;
                    }
                }
                //判断：如果没有交换位置就跳出循环
                if(bool){
                    break;
                }
            }
            //把数组返回
            return a;
        }

        4.判断一个数是否是素数(又叫质数，只能被1和自身整数的数)
                正向不好判断：如果可以分成x*y就不是素数;
        alert(isPrime(2));
        alert(isPrime(3));
        alert(isPrime(4));
        alert(isPrime(5));
        function isPrime(num){
            //思路：判断2到num-1之间所有的数，是否有能够被整除的
            for(var i=2;i<=num-1;i++){
                //判断：整个for循环中的i，如果有一个能够被整除也不是素数;
                if(num%i == 0){
                    //整除了，就不是素数;
                    return false;
                }
            }
            //如果整轮循环都不能证明他不是一个素数，那他就一定是一个素数;
            return true;
        }

        //拓展：
        function isPrime(num){
            //开闭原则;
            var bool = true;
            //没有必要判断到num，因为超过一半后面的就没有意义了，商只能是1.000001-1.9999之间;
            for(var i=2;i<=num/2;i++){
                if(num%i == 0){
                    bool = false;
                    break;//有一个能够整除后面的就不用看了！
                }
            }
            return bool;
        }

        5.输入一个年份，判断是否是闰年[闰年：能被4整数并且不能被100整数，或者能被400整数]
        function isRN(year){
            //能被4整数并且不能被100整数，或者能被400整数
            if(year%4==0 && year%100!=0 || year%400 ==0){
                return true;
            }
            return false;
        }

    拓展
        function isRN(year){
            //能被4整数并且不能被100整数，或者能被400整数
            var bool = false;//这个开闭原则默认为不通过！
            if(year%4==0 && year%100!=0 || year%400 ==0){
                bool = true;
            }
            return bool;
        }

    1.输入某年某月某日，判断这一天是这一年的第几天？
        思路：累加当月的天数，之前月份的所有天数，和当前是否是闰年;
        自定义一个数组，装着每个月的天数，以平年为准
         ，如果是闰年，且大于2月，增加1天;

    测试：
        alert(getDay(2015,1,1));
        alert(getDay(2015,2,1));

        alert(getDay(2015,3,1));//平年
        alert(getDay(2016,3,1));//闰年

        function getDay(year,month,day){
            //累计天数;  日期，月份，闰年;
            var arr = [31,28,31,30,31,30,31,31,30,31,30,31];
            //日期
            var sum = day;
            //月份:1.月份索引值为0；   2.不能获取当前月份;
            for(var i=0;i&lt;month-1;i++){//month-1不希望取到当前月份;
                sum+=arr[i];//索引值从0开始，不能写等号，不能取到当前月份;
            }
            //闰年,且大于2月;
            if(isRN(year) && month>2){//函数嵌套
                sum++;
            }
            //把总天数返回
            return sum;
        }


    //    判断：是不是闰年
        function isRN(y){
            if(y%4==0&&y%100!=0||y%400==0){
                return true;
            }
            return false;
        }
```


## arguments对象
```JavaScript
       只有在函数中才存在arguments;  实参组成的一个数组;
            1.callee: 整个函数;
            2.length: 实参个数;

        console.log(arguments);

        fn(1,2,3,4,5,6,7);
        function fn(a,b){
            console.log(arguments);//实参数组
            console.log(arguments.length);//实参数个
            console.log(fn.length);//形参数个

            console.log(arguments.callee);//整个函数
            document.write(arguments.callee);//整个函数
        }
```


## 匿名函数和自调用
```JavaScript
        匿名函数：没有名字的函数;
            function (){
                alert(111);
            }

        用处;(百万雄师下江南...)
        //1.事件绑定;
             document.onclick = function(){alert(111);}
        //2.定时器;
             setInterval(function(){console.log(222)},1000);
        //3.事件监听....


        函数的自调用;
            fn();//函数名();
            function fn(){
                alert(333);
            }
        //函数名 === 整个函数;
        document.write(fn);


        匿名函数可以自己调用自己
            (function (){
                alert("我是匿名函数");
            })();
```


##  函数小技巧
```JavaScript
    0.函数不调用不执行;
    1.函数名就等于（整个函数）
    2.就近原则使用变量
    3.两个平级的函数中的变量不会相互影响（可以使用同样的形参名）

    0.函数不调用不执行;
    1.函数名就等于（整个函数）
        function fn(){
            console.log(111);
        }
        document.write(fn);

        打印函数名和打印执行函数的区别:
        document.write(fn);//整个函数；
        document.write(fn());//功能+打印返回值

    2.就近原则使用变量
        var num = 111;
        var aaa = 111;
        fn(222)
        function fn(aaa){
            //函数自己有，不会使用别人的;
            var num = 222;
            console.log(num);
            console.log(aaa);//也是使用自己的;
        }

    3.两个平级的函数中的变量不会相互影响（可以使用同样的形参名）
        function fn1(aaa){
            console.log(aaa);
        }
        function fn2(aaa){
            console.log(aaa);
        }

        fn1(111);
        fn2(222);
```

##  递归-闭包-回调函数
```JavaScript
	递归：函数自己调用自己;
	递归必须有跳出条件，否则就是死循环;
	    var num = 1;
	    fn();
	    function fn(){
	        console.log(num);
	        num++;
	        if(num == 11){
	            return;//跳出条件；
	        }
	        fn();
	    }
	
	闭包：函数作为返回值;
	        函数内部的变量让外部使用;
	    function fn(){
	        return function () {
	            console.log(111);
	        }
	    }
	
	回调函数：函数作为参数进行传递和调用;被传递和调用的函数就叫回调函数；
	
	案例1：
	    fn(test1);
	
	    function fn(aaa){
	        aaa();//aaa他一定是一个函数;回调函数；
	    }
	
	    function test1(){
	        console.log("我是作为回调函数的函数，用于测试！！！");
	    }
	
	案例2：
	    fn(1,2,test1);
	
	    function fn(num1,num2,demo){
	        demo(num1,num2);//demo是回调函数;把fn的两个参数，作为自己的实参传递进去了
	    }
	
	    function test1(n1,n2){
	        alert(n1+n2);
	    }
	
	案例3：回调函数一般用于定义一种规则;
	
	    测试回调函数;
	    fn(10,5,test1);
	    fn(10,5,test2);
	    fn(10,5,test3);
	    fn(10,5,test4);
	
	    //定义加减乘除四则运算规则;
	    function fn(num1,num2,demo){
	        var num = demo(num1,num2);
	        alert(num);
	    }
	
	    //定义加减乘除四则运算规则;
	    function test1(n1,n2){
	        var aaa = n1 + n2;
	        return aaa;
	    }
	    function test2(n1,n2){
	        return n1 - n2;
	    }
	    function test3(n1,n2){
	        return n1 * n2;
	    }
	    function test4(n1,n2){
	        return n1 / n2;
	    }
```

## 函数总结
```JavaScript
        函数三点需要我们注意：

        1.封装;功能和逻辑是最难的;
                需要经验的积累!!!(需要经验)

        2.参数;什么时候定义参数，定义谁为参数！
                谁变化就定义谁为参数!!!(需要经验)

        3.返回值; 函数内部计算的变量外部想要使用就用return返回;
                外部使用内部值的时候;(如果使用的是逻辑和功能，就不用了)(需要经验)

        函数使用一般用两点：a.返回值;  b.逻辑和功能;
```

## 变量和作用域
```JavaScript
    根据作用范围的不同变量可以分为两类：
    1.全局变量(成员变量);哪里都可以访问到的变量;
            a.函数外部的用var定义的变量就是全局变量；
            b.任何位置不适用var定义的变量都是全局变量；
                    函数范围内的不适用var定义的全局变量需要执行一次函数才能访问;
    2.局部变量;只有在局部范围内能够访问的变量;
            a.函数范围内，使用var定义的变量;

        var num1 = "我是全局变量1";
        num2 = "我是全局变量2";
        console.log(num1);
        console.log(num2);

    //在函数里面也可以访问到全局变量
    fn();
        console.log(num2);//外部无法使用函数内部的局部变量
        console.log(num3);//函数加载的时候只加载函数名，不加载函数体;

        function fn(){
            var num22 = "我是局部变量";
            num3 = "我是全局变量3";
            console.log(num1);
            console.log(num22);
            console.log(num2);
            console.log(num3);
        }

    全局变量：哪里都能够访问到，污染变量；
    局部变量：只有函数内部能够够访问到，函数执行完毕立刻回收；

    隐式全局变量：就是不容易被发现的全局变量;
        fn();
        console.log(a);
        console.log(b);
        console.log(c);

        function fn(){
            =并不能公用一个var；
            var a = b = c = 1;//a局部变量，b和c就是隐式全局变量;
            ;并不能公用一个var；
            var a = 1;b=2;c=3;//a局部变量，b和c是隐式全局变量;
            ,可以公用一个var；
            var a = 1,b= 2,c=3;//a局部变量，b和c局部变量，
        }

    作用域链; 只能在同一函数中调用里面的函数，不能跨越函数;
                除非顶级函数，可以两个相互嵌套调用;
        f1();
        function f1(){
            f3();
            f4();//无法访问;

            function f2(){

            }
        }

        function f3(){
            function f4(){
                //无法访问：f1和f2;
            }
        }
```

## 预解析
```JavaScript
        预解析：js代码和函数加载的时候，先不执行，js看一眼;
            1.解决语法错误;
            2.变量和函数声明提升;

        1.解决语法错误;
        console.log(111);
        console.log(222);
        console.log(aaa;

        2.变量和函数声明提升;(在函数中照样会出现)
                a.变量声明提升的时候，只提升变量名，不提升变量值;(必须带有var)
                b.函数声明提升的时候，提升变量名和值（整体提升）;
                c.声明提升的时候先提升变量，在提升函数;(函数的权限比变量的权限高)

        a.变量声明提升的时候，只提升变量名，不提升变量值;
            var num;
            console.log(num);
            num = 111;

        b.函数声明提升的时候，提升变量名和值（整体提升）;
            console.log(fn);
            function fn(){
                console.log(222);
            }

        c.声明提升的时候先提升变量，在提升函数;
               var aaa;
               function aaa(){//把变量层叠掉；

               }

            console.log(aaa);
            aaa = 111;//把函数层叠掉；
            function aaa(){//把变量层叠掉；

            }
            console.log(aaa);
```

## 面试题
```JavaScript
	案例1
        var a = 25;
        function abc() {
        //  var a;
            alert(a);
            var a = 10;//就近原则;
        }
        abc();

         案例2:变量声明提升在函数声明提升之前；
        var a;
        function a() {
            console.log('aaaaa');
        }

        console.log(a);
        function a() {
            console.log('aaaaa');
        }
        var a = 1;
        console.log(a);
```
# 函数的进阶
## 函数也是对象
```JavaScript
    函数的定义有三种方法：

    //1.字面量: 函数声明提升可以让任何位置都可以访问到这个函数;
    function fn1(){
        console.log("我是第一种!");
    }

    //2.匿名函数赋值（函数表达式）: 使用函数必须在定义函数之后;
    var fn2 = function (){
        console.log("我是第二种!");
    }
    
    3.构造函数法：函数也是对象！(函数都是Function构造函数实例化出来的对象)
        Function和Array/Date/String...  都是内置对象;
    var fn3 = new Function("num1","num2","console.log(num1+num2)");
    console.log(fn3);

    fn3(111,222);
    console.log(typeof fn3);
    
    函数也是对象的一种：可以定义属性和方法;
            函数也有自己的属性和方法：属性：name/prototype/__proto__
            函数也有自己的属性和方法：方法：call()/apply()/bind();
    fn3.name = "fn3";
    fn3.age = "1周岁";
    fn3.sayHi = function () {
        console.log("我是fn3！！！")
    }

    console.log(fn3.name);//函数名是只读的，不能写入;
    console.log(fn3.age);//可以自定义属性;
    fn3.sayHi();//可以自定义方法
```

## 函数的调用方法
```JavaScript
   函数的调用方法：
    - 1.普通函数
    - 2.构造函数
    - 3.对象方法
    
        - 1.普通函数
    fn1();
    function fn1(){
        console.log(1);
    }

        - 2.构造函数
    var aaa = new Stu();
    console.log(aaa);
    function Stu(){
        this.name = "222";
    }

        - 3.对象方法
    var t1 = new Teacher();
    t1.teach();
    function Teacher(){
        this.teach = function () {
            console.log("扶我起来，我还可以在敲一段......")
        }
    }
    
    其他：
    setInterval(function () {
        console.log(1);
    },1000)

    document.addEventListener("click", function () {
        console.log(2);
    })
    document.onclick();
```

## this的指向
```JavaScript
    函数中this的指向问题：

    普通函数调用        window
    构造函数调用        实例对象
    原型方法中          this:实例对象
    对象方法调用        该方法所属对象（实例对象）
    事件绑定方法        绑定事件对象(事件源)
    定时器函数          window

    普通函数调用        window
    fn1();
    function fn1(){
        console.log(this);
    }
    构造函数调用        实例对象
    var bbb = null;
    var aaa = new Stu("张三");
    console.log(aaa)
    console.log(aaa === bbb)//同一片内存空间；
    function Stu(name){
        this.name = name;
        console.log(this);
        bbb = this;
    }

    原型方法中          this:实例对象
    function Stu(){}
    //原型方法定义，没有变量声明提升;
    Stu.prototype.sayHi = function () {
        console.log(this);
        bbb = this;
    }

    var bbb = null;
    var aaa = new Stu();
    aaa.sayHi();
    console.log(aaa);
    console.log(aaa === bbb);

    对象方法调用        该方法所属对象（实例对象）
    var bbb = null;
    var aaa = new Stu();
    aaa.sayHi();
    console.log(aaa);
    console.log(aaa === bbb);
    function Stu(){
        this.sayHi = function () {
            bbb = this;
            console.log(this);
        }
    }

    事件绑定方法        绑定事件对象(事件源)
    document.onclick = function () {
        console.log(this);
    }

    定时器函数          window
    var timer = setInterval(function () {
        console.log(this);
    },1000);
```

## this的指向可以改变（call-apply-bind）
```JavaScript
   函数中this的指向可以改变;
        利用函数中的call()/apply()/bind();
    
    call();是任何函数都有的内置方法;  作用就是把this从原来的指向改为指定项;
        用法;   函数.call(指定项，参数1，参数2.....);  直接执行;

    var obj = new Object();
    obj.name = "用于测试改变this";
    (function(){
        console.log(this);
    }).call(obj);
    
    给文档绑定点击事件
    document.onclick = function () {
        console.log("很多逻辑。。。");
        console.log(this);
        console.log("很多逻辑。。。");
    }

    //onmouseover的时候也调用documnet.onclick的逻辑，但是this要指向别处;
    document.onmouseenter = function () {
        var obj = new Object();
        obj.name = "我是学生！"
        document.onclick.call(obj);
    }
    
    从今以后就不能在说能用this都用this了！
```

## 改变this
```javascript
   //for循环绑定事件的时候函数中一般不用i，用this；
    var liArr = document.getElementsByTagName("li");
    for(var i=0;i<liArr.length;i++){
        liArr[i].onclick = function () {
            console.log(this);
        }

       /* 闭包
        liArr[i].onclick = function (aaa) {
            return function () {
                console.log(liArr[aaa]);
            }
        }(i);*/
    }
    
    /*function Stu(name,age){
        this.name = name;
        this.age = age;
    }*/
    var stu1 = new Stu("真三",18);
    
    liArr[0].onclick();//第一个直接被绑定;
    liArr[0].onclick.call(stu1);
```

## 数组中函数的调用
```javascript
     var arr = [
        function () {
            console.log("我是数组中的第1个");
        },
        function () {
            console.log("我是数组中的第2个");
        },
        function () {
            console.log("我是数组中的第3个");
        }
    ];
    
    执行数组中的元素;（第一种）
    arr[0]();
    for(var i=0;i<arr.length;i++){
        (arr[i])();
    }

    执行数组中的元素;（第二种）
    arr.forEach(function (ele,index,array) {
        ele();//推荐
        array[index]();
        arr[index]();
    })

```

## 改变this的指向（call-apply-bind）
```javascript
     call()/apply()/bind()
        调用者：函数;
        参数：  要改变this的指向的对象;  调用者需要的参数...
        功能：  执行函数/返回函数并改变this的指向
        返回值：undefined、并改变this之后的函数;
    
    1.call();
        调用者：函数;
        参数：  要改变this的指向的对象;  调用者需要的参数...(单个传递)
        功能：  执行函数函数并改变this的指向
        返回值：undefined；
            this的指向对象不写或者写null都指向window；

    function fn(num1,num2){
        console.log(num1+num2);
        console.log(this);
    }

    var aaa = fn(111,222);
    fn.call(document,333,666);
    fn.call(null,333,666);      //this的指向对象不写或者写null都指向window；
    fn.call();
    console.log(aaa)
    
    2.apply();
        调用者：函数;
        参数：  要改变this的指向的对象;  调用者需要的参数数组...(数组)
        功能：  执行函数函数并改变this的指向
        返回值：undefined；
            this的指向对象不写或者写null都指向window；

    var bbb = fn.apply(document.body,[333,444]);
    fn.apply(null,[111,222])
    
    3.bind();
        调用者：函数;
        参数：  要改变this的指向的对象;  调用者需要的参数...(单个传递)
        功能：  执行函数函数并改变this的指向然后赋值
        返回值：改变了this指向的一个函数(参数已经设置完毕不能修改了)；
            this的指向对象不写或者写null都指向window；
    
    var aaa = fn.bind(document.documentElement,111,222);
    console.log(aaa);
    aaa();
    aaa(222,333);//改变不了里面的变量
```

### 赋值改变指向问题
```javascript
     赋值改变指向问题
    var num = 111;
    var obj = {
        num: 222,
        fire: function () {
            console.log(this.num);
        }
    };
    
  /*  var fn = obj.fire;
    fn();*/

    var fn = obj.fire.bind(obj);
    fn();
```

## call-apply-bind区别总结
```javascript
   call()/apply()/bind()

    总结：1.调用者都是函数，都是为了改变this的指向;
    总结：2.调用者函数有的执行(call/apply)有的不执行(bind);
    总结：3.根据传递参数的不同：单个参数传递(call/bind)和数组形式传递(appley);

    总结：4.call()直接调用改变this / bind()返回一个函数实体用于执行;
```

## call-apply-bind使用场景分析
```javascript
     call()/bind()
        什么时候使用？ 想改变this的指向的时候使用;
        想用逻辑还不想用this，不想用this指的值;
    
    call();
        简单数据类型检测：typeof;
        复杂数据类型检测：A instanceof B;  A是否是B类型
        用call方法检测复杂数据类型是什么创建出来的！
    console.log(Object.prototype.toString())
    console.log(Object.prototype.toString.call(Math))
    console.log(Object.prototype.toString.call(new Date()))
    console.log(Object.prototype.toString.call(new Array))
    function Student(){}
    //不支持自定义对象验证;
    console.log(Object.prototype.toString.call(new Student()))
    console.log(new Student().__proto__.constructor)
    
    bind();
        贪吃蛇演示;
    (function(window){
        function Game(map){
            this.food = new Food();
            this.snake = new Snake();
            this.map = map;
        }

        /*把原来贪吃蛇中内部的一个独立方法改为，
        Game构造函数原型上的一个方法;(因为变成了原型方法，就可以不传递food/snake/map)
        改用this.food;this.snake;this.map;*/
        Game.prototype.pressKey = function () {
            //1.在页面上按键，改变方向;
            //  var that = this;
            document.onclick = function () {
                //根据按钮，改变蛇的deriction的属性值；
                //this代指函数调用者;document;(我们要的是Game的实体对象;)
                //2.改变this的指向
                this.snake.deriction = "left";
                //外面已经保存完毕;
             // that.snake.deriction = "left";
            }.bind(this);
        }

        window.Game = Game;
    }(window))

```

## 函数中的几个成员
```javascript
    - arguments
      - 实参伪数组
    - caller
      - 函数的调用者
            全局范围内调用null；
            另一个函数中调用，就是外面的那个函数;
    - length
      - 形参的个数
    - name
      - 函数的名称

    window.fn1(111,222,333);
    function fn1(n1,n2){
      /*  console.log(fn1.arguments);//内置对象，是fn1的属性: 也可以省略函数名
                arguments：lenght；实参个数;
                arguments：callee；整个函数;
        console.log(arguments);// 也可以省略函数名
        console.log(fn1.caller);//函数没有调用者是null*/
        console.log(fn1.length);
        console.log(fn1.name);

        fn2();
        function fn2(){
            console.log(fn2.caller);
        }
    }

    arguments.callee.name;//函数名；
```

## 沙箱
```javascript
   沙箱：一个封闭的空间里面可以写自己的逻辑;(模拟块级作用域)

    其他语言中块级作用域内部的内容，执行完毕内存就回收了！
    {
        var num = 111;
        console.log(num);
    }

    js用匿名函数自调用模拟沙箱模拟块级作用域;
    第一种
    (function(num){
        var num = 111;
        //把num提升为全局变量
        window.num = num;
    }(111))

    //第二种;
    (function(window){
        var aaa = 111;
        var bbb = 222;
        var ccc = 333;
    })(window)
    
    好处1：可以把局部变量变成全局变量很方便;
    好处2：可以避免全局变量污染;
    好处3：可以不管全局变量有什么变量名，我直接使用;
```

## 沙箱案例
```javascript
	    <div>我是div</div>
	    <div>我是div</div>
	    <div>我是div</div>
	    <p>我是P标签</p>
	    <p>我是P标签</p>
	    <p>我是P标签</p>
	<script>
	    //声明提升;
	//    var getEle;
	//    function getEle(){
	//
	//    }
	
	    //全局变量有名字了局部变量还可以设置：
	    var getEle = 111;
	    var setDiv = 222;
	    var setP = 333;
	
	    (function(){
	        //可以放心大胆的使用变量名！
	        function getEle(str){
	            return document.getElementsByTagName(str);
	        }
	
	        function setDiv(arr){
	            for(var i=0;i<arr.length;i++){
	                arr[i].style.border = "1px solid skyblue";
	            }
	        }
	
	        function setP(arr){
	            for(var i=0;i<arr.length;i++){
	                arr[i].style.border = "1px solid yellowgreen";
	            }
	        }
	
	        //设置div和p的样式
	        setDiv(getEle("div"));
	        setP(getEle("p"));
	
	    }())
	
	    console.log(getEle);
	    console.log(setDiv);
	    console.log(setP);
	</script>
```

## 方法的种类
```javascript
    方法的位置：
            1.普通对象方法;
            2.原型方法;
            3.模拟静态方法;（把方法绑定到构造函数上）
        
        function Student(name){
            this.name = name;
            //1.普通对象方法;
            this.sayHi = function () {
                console.log("1.普通对象方法;");
            }
        }
        //2.原型方法;
        Student.prototype.init = function () {
            console.log("2.原型方法;");
        }
        Student.aaa = function () {
            console.log("3.模拟静态方法;（把方法绑定到构造函数上）");
        }
        
        var stu = new Student("张三");
        //1.普通对象方法;
        stu.sayHi();
        //2.原型方法;
        stu.init();
        //3.模拟静态方法;（把方法绑定到构造函数上）
        Student.aaa();
```

## 函数的高级操作（3种）
```javascript
    1.回调函数: 函数当作参数进行传递和调用;
        2.闭包: 函数作为返回值;
        3.递归: 函数自己调用自己;
        
        1.回调函数: 函数当作参数进行传递和调用;
        setInterval(function () {
            console.log(111);
        },1000);
        
        forEach();sort();document.addEventListener()......
                
        2.闭包: 函数作为返回值;
                一般关键在于返回值;
        function fn(){
            return function () {
                console.log(222);
            }
        }

        var aaa = fn();
        aaa();
        
        3.递归: 函数自己调用自己;
                递归必须有跳出条件，否则就是死循环
                省去for循环;
        var num = 0;
        function fn(){
            num++;
            console.log(num);
            if(num < 3){
                fn();
            }
        }

        fn();
```

## 闭包
```javascript
     <ul>
        <li>1</li>
        <li>2</li>
        <li>3</li>
        <li>4</li>
        <li>5</li>
    </ul>

    <script>

        1.回调函数: 函数当作参数进行传递和调用;
        2.闭包: 函数作为返回值;
        3.递归: 函数自己调用自己;
        
        2.闭包: 函数作为返回值;
            很高的概率在于使用函数内部的变量;
                a.普通变量;
                b.形参;
        
        function fn(){
            return function () {
                console.log("体验闭包");
            }
        }
        
        第一种;
        var aaa = fn();
        aaa();//执行了一次闭包，但结果被执行了四次;
        aaa();//执行了一次闭包，但结果被执行了四次;
        aaa();//执行了一次闭包，但结果被执行了四次;
        aaa();//执行了一次闭包，但结果被执行了四次;
        第二种;
        fn()();//执行了四次闭包;
        fn()();//执行了四次闭包;
        fn()();//执行了四次闭包;
        fn()();//执行了四次闭包;
        
        真是体验;(使用函数中的局部变量)

        function fn(){
            var num = 1;//当做全局变量用
            //return num;//让外部使用内部的值;是把1返回，让外部使用;
            return function () {//让函数外部能够使用函数内部的变量
                return ++num;
            }
        }
        
        第一种;
        var aaa = fn();
        console.log(aaa());//2
        console.log(aaa());//3
        console.log(aaa());//4
        console.log(aaa());//5

        第二种：(禁止这样闭包)
        console.log(fn()());//2;每次执行闭包，num都被初始化为1；
        console.log(fn()());//2;每次执行闭包，num都被初始化为1；
        console.log(fn()());//2;每次执行闭包，num都被初始化为1；
        console.log(fn()());//2;每次执行闭包，num都被初始化为1；
         
        b.形参;(弹出索引值)
        var liArr = document.getElementsByTagName("li");

        for(var i=0;i<liArr.length;i++){
            liArr[i].onclick = fn(i);//函数自调用
        }

        function fn(num) {
            //匿名函数中的i不能使用;
            return function () {
                console.log(num);
            }
        }
        
        测试debug
        function fnn(){
            console.log(111);
            console.log(222);
            console.log(333);
        }

    </script>

```

## 闭包案例（tab栏）
```css
<style>
        * {
            padding: 0;
            margin: 0;
            list-style: none;
        }

        .box {
            width: 400px;
            height: 300px;
            overflow: hidden;
            margin: 150px auto;
            border: 1px solid #ccc;
        }

        ul {
            overflow: hidden;
        }

        ul li {
            float: left;
            width: 80px;
            height: 40px;
            text-align: center;
            font: 20px/40px 'simsun';
            cursor: pointer;
            background-color: yellowgreen;
        }

        span {
            display: none;
            width: 400px;
            height: 260px;
            text-align: center;
            background-color: skyblue;
            font: 700 80px/260px 'simsun';
        }

        .current {
            background-color: skyblue;
        }

        .show {
            display: block;
        }
    </style>
```
```javascript
    <script>
        window.onload = function () {
            var liArr = document.getElementsByTagName("li");
            var spanArr = document.getElementsByTagName("span");
            //绑定事件
            for (var i = 0; i < liArr.length; i++) {
                //利用闭包获取i然后在设置;
                liArr[i].onclick = function (num) {
                    //闭包要返回一个函数
                    return function () {
                        //num就是真实点击的i;
                        //排他思想
                        for(var j=0;j<liArr.length;j++){
                            liArr[j].className = "";
                            spanArr[j].className = "";
                        }
                        //剩下我自己;
                        this.className = "current";
                        //num就是真实点击的i;
                        spanArr[num].className = "show";
                    }
                }(i);
            }
        }
    </script>
```
```HTML
    <div class="box">
    <ul>
        <li class="current">裤子</li>
        <li>袜子</li>
        <li>裙子</li>
        <li>鞋子</li>
        <li>帽子</li>
    </ul>
    <span class="show">裤子区域1</span>
    <span>袜子区域2</span>
    <span>裙子区域3</span>
    <span>鞋子区域4</span>
    <span>帽子区域5</span>
</div>

```

## 闭包案例（模拟缓存）
```javascript
    模拟缓存：空间有限，如果超出覆盖掉之前的内容;
        
        function fn(){
            //我们在这个对象中只允许存放3对数据;
            var obj = {};
            //如何判断obj里面有几对数据;(设置一个数组，把属性放入数组中)
            var arr = [];
            //使用闭包返回一个函数，让外部可以使用obj;
            return function (key,value) {
                //判断：obj里面有几对数据;
                if(arr.length < 3){//不能等于3,如果等于了再添加就变成4对了
                    //不足3对，设置设置属性值;
                    obj[key] = value;
                    //添加到数组中
                    arr.push(key);
                }else{
                    //等于3对，删除第一个，添加新的属性值；
                    //a.删除第一个
                    delete obj[arr[0]];//把obj里面的数组中的第一个属性删除;
                    arr.shift();

                    //添加新的属性值；
                    obj[key] = value;
                    arr.push(key);
                }
                //让外部能够看到
                return obj;
            }
        }
        
        //测试
        var aaa = fn();
        console.log(aaa("a",1));
        console.log(aaa("b",2));
        console.log(aaa("c",3));
        console.log(aaa("d",4));
        console.log(aaa("e",5));
        
        var aaa = fn();
        console.log(aaa("a",1));

        //点赞
```

## 递归
```javascript
    1.回调函数: 函数当作参数进行传递和调用;
        2.闭包: 函数作为返回值;
        3.递归: 函数自己调用自己;
        
        3.递归: 函数自己调用自己;
            递归必须能够停止否则就是死循环;
                递归非常相似for循环;
            a.停止递归：不在调用;
            b.停止递归：跳出函数(在调用函数之前跳出);
        
        体验递归
        var num = 1;
        fn();//函数中需要的变量之后调用;

        function fn(){
            console.log("从前有座山，山里有座庙，
            庙里有个老和尚，老和尚给小和尚讲故事，讲的什么故事呢?....."+num);
            num++;
            //a.停止递归：不在调用;
               //  if(num<100){
               // fn();
            //}
            //b.停止递归：跳出函数(在调用函数之前跳出);
            if( num > 5 ){
                return;
            }
            fn();
        }
        
        求和1-100;
        var sum = 0;
        var num = 1;

        function getSum(){
            sum += num;
            num++;
            if(num<=100){
                getSum();
            }
        }

        getSum();
        alert(sum);

```

## 递归案例（5个）
```javascript
    1.求和;(不能使用全局变量，可以使用参数)
        2.阶乘;(不能使用全局变量，可以使用参数)

        3.求等差数列(  1   3   5   7   9);   前多少位;
        4.求等比数列(  1   3   9   27   );   前多少位;
        
        5.求斐波那契数列( 1 1 2 3 5 8 13..);  指定位;
        
        
        1.求和;(不能使用全局变量，可以使用参数)
        function getSum(num){
            if(num == 1){
                return 1;
            }
            return num+getSum(num-1);
        }

        alert(getSum(100));
        
        2.阶乘;(不能使用全局变量，可以使用参数)
        function getJC(num){
            if(num === 1){
                return 1;
            }
            return num*getJC(num-1);
        }

        alert(getJC(3))
        
        3.求等差数列(  1   3   5   7   9  );   前多少位;
        function getDCSL(num){
            if(num === 1){
                return 1;
            }
            return 2*num-1+getDCSL(num-1);
        }

        alert(getDCSL(5));

        4.求等比数列(  1   3   9   27   );   前多少位;
        function getDB(num){
            if(num == 1){
                return 1;
            }
            return Math.pow(3,num-1)+getDB(num-1);
        }

        alert(getDB(4));
        
        5.求斐波那契数列( 1 1 2 3 5 8 13..);  指定位;
        function FBNQSL(n){
            if(n ==1 || n==2){
                return 1;
            }
            //累加
            return FBNQSL(n-1)+FBNQSL(n-2);
        }

        alert(FBNQSL(12));
```

## 闭包案例

   
```css
    <style>
        button {
            margin: 20px;
            width: 120px;
            height: 50px;
            cursor: pointer;
            font-size: 18px;
        }
    </style>
```
```javascript
    <script>
        window.onload = function () {
            //需求：点击按钮，里面的次数+1；
                //思路：1.不用全局变量；2.不用自定义属性;
                //思路：用闭包控制局部变量;

            //步骤：老三步;

            var btnArr = document.querySelectorAll("button");
            //绑定事件
            for(var i=0;i<btnArr.length;i++){
                btnArr[i].onclick = fn();
            }

            //封装fn；（闭包实现点击以后数值增加）
            function fn(){
                var value = 0;
                return function () {
                    //不需要改变this的指向，所以this值事件调用者(被点击的按钮);
                    this.innerHTML = "赞（"+(++value)+"次）";
                }
            }
        }
    </script>
```
```html
    <button>赞（0次）</button>
    <button>赞（0次）</button>
    <button>赞（0次）</button>
    <button>赞（0次）</button>
    <button>赞（0次）</button>
```

## 浅层复制对象
```javascript
   var obj1 = {
        "name": "小沈阳",
        "age": 28,
        "sayHi": function () {
            console.log(111);
        },
        "address": ["中国","辽宁省","铁岭市","莲花乡","池水沟村"],
        "teacher": {"name":"赵老憨儿","age":58}
    };

    封装一个方法，可以赋值对象里面的每一个属性值;
    function extend(object1,object2){
        //用for...in...把第一个里面的属性和方法都设置到第二个中;
        for(var k in object1){
            //把object1里面的属性值，赋值到object2中
            object2[k] = object1[k];
        }
    }

    var obj2 = {};

    console.log(obj2);

    调用extend方法
    extend(obj1,obj2);

    obj1.teacher.name = "李四";//复杂数据类型传递的是地址;
    console.log(obj2);
```

## 深层复制对象（递归）
```javascript
   var obj1 = {
        "name": "小沈阳",
        "age": 28,
        "sayHi": function () {
            console.log(111);
        },
        "address": ["中国","辽宁省","铁岭市","莲花乡","池水沟村"],
        "teacher": {"name":"赵老憨儿","age":58}
    };
    
    封装一个方法，可以赋值对象里面的每一个属性值;
    function extend(object1,object2){
        //用for...in...把第一个里面的属性和方法都设置到第二个中;
        for(var k in object1){
            //把object1里面的属性值，赋值到object2中

            //想要深处赋值，要注意：如果是对象/数组，要创建新的利用递归实现深层复制;
            //object2[k] = object1[k];
            if(object1[k] instanceof Array){
                var value = [];
                //然后利用递归设置;
                object2[k] = value;
                extend(object1[k],value);
            }else if(object1[k] instanceof Object){
                var value = {};
                //然后利用递归设置;
                object2[k] = value;
                extend(object1[k],value);
            }else{
                object2[k] = object1[k];
            }
        }
    }
    
    var obj2 = {};
    
    console.log(obj2);

    调用extend方法
    extend(obj1,obj2);

    obj1.teacher.name = "李四";//复杂数据类型传递的是地址;
    console.log(obj1);
    console.log(obj2);
```

## 遍历DOM树
```javascript
    <script>
        window.onload = function () {
            //需求：获取页面上的所有元素，打印他们的标签名;
                    //思路：获取html->在获取他的子元素-->在获取他的子元素-->...

            //测试：hmtl
            var root = document.documentElement;
           // forDom(root);
            
            测试2：
            forDom(root, function (element) {
                element.onclick = function (event) {
                    alert(this.tagName);
                    //取消冒泡
                    event.stopPropagation();
                }
            })
            
            第一种实现：
            打印所有标签的标签名;
            function forDom(ele){//不包括ele本身元素;
                //获取ele里面的所有子元素，打印名字;
                for(var i=0;i<ele.children.length;i++){
                    //功能实现;(将来功能拓展可以传递其他功能)
                    console.log(ele.children[i].tagName);
                    //判断：如果该标签有子孙元素，可以继续调用forDom;
                    if(ele.children[i].children.length !== 0){
                        forDom(ele.children[i]);
                    }
                }
            }
            
            拓展：(功能拓展：功能不能仅仅就是打印名字)
            function forDom(ele,fn){//fn作为回调函数，可以传递功能
                //获取ele里面的所有子元素，打印名字;
                for(var i=0;i<ele.children.length;i++){
                    //功能实现;(将来功能拓展可以传递其他功能)
                  // console.log(ele.children[i].tagName);
                    fn(ele.children[i]);
                    //判断：如果该标签有子孙元素，可以继续调用forDom;
                    //&&运算优化;(利用短路)
                    ele.children[i].children.length!=0 && forDom(ele.children[i],fn);
                }
            }

        }
    </script>
```

```css
    <ul>
        <li></li>
        <li></li>
        <li></li>
    </ul>

    <ol>
        <li></li>
        <li></li>
        <li></li>
    </ol>

    <p>1</p>
    <p>2</p>
    <p>3</p>

    <div>
        <ul>
            <li>
                <a href="#"><img src="" alt=""/></a>
            </li>
        </ul>
    </div>

    <i>4</i>
    <i>5</i>
    <i>6</i>
```

## 作用域变量预解析
```javascript
   1.作用域：全局作用域和局部作用域;
    2.变量：全局变量和局部变量;
    3.预解析:
        a.检查语法错误;
        a.生命提升;
            I.变量声明提升，只提升变量名，不提升变量值;
            II.函数声明提升，是整体提升
            III.变量声明提升在函数声明提升之前
```

## 伪数组
```javascript
    伪数组不是数组是看着像数组;
        1.他是对象;   2.没有数组里面的方法;   3.看着像;  [1,2,3]和length;


    模拟伪数组;
    function Arr(){
        for(var i=0;i<arguments.length;i++){
            this[i] = arguments[i];
        }
        this.length = arguments.length;
    }
    Arr.prototype.push = function (ele) {
        this[this.length] = ele;
        this.length += 1;
        return this.length;
    }
    
    //看看伪数组;
    var weiArr = new Arr("a","b","c");
    var aaa = weiArr.push("123");
    console.log(weiArr);
    console.log(aaa);
```